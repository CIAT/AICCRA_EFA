---
title: "AICCRA - EFA"
author: "Peter Steward"
date: "5/12/2022"
output: html_document
runtime: shiny
---
<style type="text/css">
.main-container {
  max-width: 1200px;
  margin-left: auto;
  margin-right: auto;
}
</style>
  
```{r Setup, include=FALSE}
knitr::opts_chunk$set(echo = F)
```

```{r Setup - load packages,echo=F}
if(!require("pacman", character.only = TRUE)){install.packages("pacman",dependencies = T)}

required.packages <- c("colourpicker",
                       "data.table",
                       "dplyr",
                       "DT",
                       "raster",
                       "terra",
                       "sf",
                       "viridis")

pacman::p_load(char=required.packages,install = T,character.only = T)

options(scipen = 999)
```

## AICCRA - Economic and Financial Analysis Tool (EFAt) {.tabset .tabset-fade .tabset-pills}

**Plotting Parameters**

:::: {style="display: flex;"}
::: {}
```{r Plot - Palette,echo=F}
  selectInput(inputId="Palette", 
              label="Fill palette",
              choices = c("magma","inferno","plasma","viridis","cividis","rocket","mako","turbo"),
              selected="turbo", 
              multiple = F,
              width="100px")
```
:::
:::{}
```{r Plot - Text size,echo=F}
  numericInput(inputId="TextSize", 
              label="Text size",
              value = 1.2,
              min=1, 
              max=20,
              step = 0.1,
              width="100px")
```
:::
:::{}
```{r Plot - Base width,echo=F}
  numericInput(inputId="PlotBaseWidth", 
              label="Plot width (px)",
              value = 1200,
              min=100, 
              max=5000,
              step = 100,
              width="150px")
```
:::
:::{}
```{r  Plot - Adjust height, echo=F}
numericInput(inputId="Plot.Height",
             label="Adjust height",
             value=0.5,
             min=0.1,
             max=3,
             step=0.1, 
             width="120px")
```
:::
:::{}
```{r Plot - Adjust width , echo=F}
numericInput(inputId="Plot.Width",
             label="Adjust width",
             value=1,
             min=0.1,
             max=3,
             step=0.1,
             width="120px")
```
:::
:::{}
```{r  Plot - Legend position,echo=F}
  selectInput(inputId="LegPos", 
              label="Legend position",
              choices = c("bottomright", "bottom", "bottomleft", "left", "topleft", "top", "topright", "right","center"),
              selected="bottomright", 
              multiple = F,
              width="150px")
```
:::
:::{}
```{r  Plot - Legend columns,echo=F}
  numericInput(inputId="LegCols", 
              label="Legend columns",
              value = 2,
              min=1, 
              max=20,
              step = 1,
              width="130px")
```
:::
:::{}
```{r Plot - Polygon boundary colour picker, echo =F}
  colourInput(inputId="BorderCol",
              label="Polygon border colour",
              value="black")
```
:::
::::

```{r Plot - Create bar height and width functions, echo=F}
  Plot.Height <- function(){input$PlotBaseWidth*input$Plot.Height}
  Plot.Width <- function(){input$PlotBaseWidth*input$Plot.Width}
```

### Datasets {.tabset .tabset-fade .tabset-pills}

```{r Livestock - Choose systems}
LSvop_options<-data.table::fread("Data/Herrero/LS Files.csv")

checkboxGroupInput(inputId="LSChoice", 
         label= "Livestock systems", 
         choices = LSvop_options[,sort(unique(System))], 
         selected = c("Bovine meat"),
         inline = T)
```


:::: {style="display: flex;"}
::: {}
```{r Crops - Choose MapSPAM technology}
MS_options<-data.table::fread("Data/MapSPAM/MS Files.csv")

selectInput(inputId="MSTech", 
         label= "Crop technology", 
         choices = MS_options[,sort(unique(Tech))], 
         selected = c("all technologies"),
         multiple = F,
         width="150px")

MSTechCode<-reactive({MS_options[Tech==input$MSTech,unique(TechCode)]})
```
:::
:::{}
```{r Crops - Choose MapSPAM area type}
selectInput(inputId="MSAreaType", 
         label= "MapSPAM area type", 
         choices = c("physical","harvested"), 
         selected = c("harvested"),
         multiple = F,
         width="150px")
```
:::
:::{}
```{r Extraction - Include totals,echo=F}
selectInput(inputId="IncTot", 
         label= "Extract totals?", 
         choices = c("Yes","No"), 
         selected = c("No"),
         multiple = F,
         width="150px")
```
:::
::::
```{r Crop - Choose crops}
renderUI({
checkboxGroupInput(inputId="CropChoice", 
         label= "Crop", 
         choices = MS_options[TechCode==MSTechCode(),sort(unique(Crop))], 
         selected = c("maize","bean","cassava"),
         inline = T)
})
```


```{r Geographies - Load CGIAR countries (evaluated),echo=F,eval=T}
CGIAR_countries_sf<-sf::read_sf("Data/CGIAR_region/CGIAR_countries_simplified.shp",options = "ENCODING=UTF8")

CGIAR_countries_sf<-CGIAR_countries_sf[CGIAR_countries_sf$CG_REG %in% c("ESA","WCA") |
                                         CGIAR_countries_sf$ADMIN %in% c("Morocco","Western Sahara","Libya","Egypt","Algeria","Tunisia","Sudan"),]

sf::st_crs(CGIAR_countries_sf)<-4326
CGIAR_countries_sf$ADMIN[CGIAR_countries_sf$ADMIN=="United Republic of Tanzania"]<-"Tanzania"
CGIAR_countries_sf$ADMIN[CGIAR_countries_sf$ADMIN=="Ivory Coast"]<-"Cote d'Ivoire"
CGIAR_countries<-terra::vect(CGIAR_countries_sf)
```

:::: {style="display: flex;"}
::: {}
```{r Geographies - Choose core countries}
checkboxGroupInput(inputId="CountriesChoice", 
         label= "Core countries", 
         choices = sort(CGIAR_countries$ADMIN), 
         selected = c("Kenya","Ethiopia","Ghana","Mali","Senegal","Zambia"),
         inline = T)



ExtractBy.Core<-reactive({
  CGIAR_countries[CGIAR_countries$ADMIN %in% input$CountriesChoice]
})
```
:::
:::{}
```{r Geographies - Choose spillover countries}
renderUI({
  checkboxGroupInput(inputId="SpillCountriesChoice", 
           label= "Spillover countries", 
           choices = sort(CGIAR_countries$ADMIN[!CGIAR_countries$ADMIN %in% input$CountriesChoice]), 
           selected =c("Burundi","Rwanda","Tanzania","Uganda","Benin","Burkina Faso","Chad","Cote d'Ivoire",
                       "Cameroon","Guinea","Gambia","Guinea-Bissau","Mauritania","Niger","Nigeria","Togo",
                       "Botswana","Malawi","Mozambique","Zimbabwe"),
           inline = T)
})

ExtractBy.Spillover<-reactive({
  CGIAR_countries[CGIAR_countries$ADMIN %in% input$SpillCountriesChoice]
})
```
:::
::::

```{r Datasets - Set base raster,echo=F}
# Set Base Raster
BaseRaster<-terra::rast("Data/cell5m_livestock_vop.tif")
```
#### Countries
```{r Datasets - CGIAR countries,echo=T,eval=F}
CGIAR_countries_sf<-sf::read_sf("Data/CGIAR_region/CGIAR_countries_simplified.shp",options = "ENCODING=UTF8")

CGIAR_countries_sf<-CGIAR_countries_sf[CGIAR_countries_sf$CG_REG %in% c("ESA","WCA") |
                                         CGIAR_countries_sf$ADMIN %in% c("Morocco","Western Sahara","Libya","Egypt","Algeria","Tunisia","Sudan"),]

sf::st_crs(CGIAR_countries_sf)<-4326
CGIAR_countries_sf$ADMIN[CGIAR_countries_sf$ADMIN=="United Republic of Tanzania"]<-"Tanzania"
CGIAR_countries_sf$ADMIN[CGIAR_countries_sf$ADMIN=="Ivory Coast"]<-"Cote d'Ivoire"
CGIAR_countries<-terra::vect(CGIAR_countries_sf)
```

```{r Datasets - Crop base raster,echo=F}
BaseRaster<-terra::crop(BaseRaster,CGIAR_countries)
CellSize.km<-terra::cellSize(BaseRaster,mask=T, unit="km")
```

```{r Datasets - plot CGIAR Countries, echo =F}
renderPlot({terra::plot(CGIAR_countries,
                        "ADMIN",
                        main="CG Countries",
                        border=input$BorderCol,
                        legend=F,
                        type="classes",
                        pax=list(cex.axis=input$TextSize),
                        col=sample(viridis(n=length(CGIAR_countries),option =input$Palette),replace=F),
                        cex.main = input$TextSize*1.2,
                        axes = F,
                        frame.plot= F
                        )},
           height=Plot.Height, width=Plot.Width)
```

#### Livestock {.tabset .tabset-fade .tabset-pills}

##### Production Systems
[GLPC Livestock Production Systems (LPS) map](https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi:10.7910/DVN/WPDSZE) by [Robinson et al. 2014](https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0096084)
```{r Datasets - GLPS, echo = T}
# GLPS
LPS<-terra::resample(terra::rast("Data/GLPS/glps_gleam_61113_10km.tif"),BaseRaster,method="near")
LPS<-terra::mask(LPS,CGIAR_countries)
GPLS_Legend<-data.table::fread("Data/GLPS/LPS_legend_RGB.csv")
GPLS_Legend[,!c("System","Irrigation","Aridity")]


LPS_Suitable<-copy(LPS)
LPS_Suitable[which(LPS_Suitable[] %in% c(13,14,15))]<-NA
LPS_Suitable<-LPS_Suitable-1
levels(LPS_Suitable)<-GPLS_Legend[1:12,System_Full]
names(LPS_Suitable)<-"LPS_Suitable"
```

```{r Datasets- Plot GLPS, echo =F}
renderPlot({terra::plot(mask(LPS_Suitable,CGIAR_countries),
                        main="Global Distribution of LPS (Robinson et al. 2014)",
                        pax=list(cex.axis=input$TextSize),
                        plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
                        col=viridis(n=length(levels(LPS_Suitable)[[1]]),option =input$Palette,direction = if(input$Palette=="turbo"){1}else{-1}),
                        cex.main = input$TextSize*1.2,
                        axes = F,
                        frame.plot= F)
          terra::plot(CGIAR_countries,add=T,border=input$BorderCol)
  },height=Plot.Height, width=Plot.Width)
```

##### Value & Yield
These datasets come from [Herrero et al. 2013](https://www.pnas.org/doi/abs/10.1073/pnas.1308149110) in particular see the [supporting information](https://www.pnas.org/doi/suppl/10.1073/pnas.1308149110/suppl_file/sapp.pdf) for a detailed explanation of their methods.

Phil Thorton confirms that livestock VoP (as for crops) was calculated as production (t) times price ($/t). In the PNAS dataset, one international (global) price was used for each commodity for comparability, and these were 2005 dollars.

**Value of production (VoP**
*VoP units are USD/km2/yr*
```{r Datasets - Load LSvop,echo=T}
LSvop1<-reactive({
  terra::rast(paste0("Data/Herrero/Resampled/",LSvop_options[System %in% input$LSChoice & Variable=="VOP",Filename]))
})

# Convert to USD/km2/yer to USD/km/pixel
LSvop2<-reactive({LSvop1()*CellSize.km})
```

```{r Datasets - LS rename and add totals}

LSfun<-function(Data,Choice,Extension,TotalName,DoSum=T,IncTot){
  names(Data)<-paste0(Choice,Extension)
  
  if(length(Choice)>1 & IncTot=="Yes"){
    if(DoSum){
      Data<- c(Data,sum(Data))
    }
    names(Data)<-c(paste0(Choice,Extension),paste0(TotalName,Extension))
  }
  return(Data)
}

# Rename layers
LSvop<-reactive({
  LSfun(Data=LSvop2(),Choice=input$LSChoice,Extension="_vop",TotalName="LS",IncTot=input$IncTot)
})


```

```{r Datasets - Plot LSvop, echo =F}
renderPlot({terra::plot(LSvop1(),
                        main="Value of livestock production (USD/pixel)",
                        pax=list(cex.axis=input$TextSize),
                        plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
                        col=viridis(n=length(levels(LPS_Suitable)[[1]]),
                                    option =input$Palette,
                                    direction = if(input$Palette=="turbo"){1}else{-1}),
                        cex.main = input$TextSize*1.2,
                        axes = F,
                        frame.plot= F)
            terra::plot(CGIAR_countries,add=T,border=input$BorderCol)
  },height=Plot.Height, width=Plot.Width)
```

**Yield & Production**
*Meat or milk yield units are kg/km2/yr*
```{r Datasets - Load LSyield,echo=T}
LSyield<-reactive({
  terra::rast(paste0("Data/Herrero/Resampled/",LSvop_options[System %in% input$LSChoice & Variable=="MeatYield",Filename]))
})
# Convert to value per pixel
LSprod2<-reactive({LSyield()*CellSize.km})

# Rename layers
LSprod<-reactive({
  LSfun(Data=LSprod2(),Choice=input$LSChoice,Extension="_prod",TotalName="LS",IncTot=input$IncTot)
})
```

```{r Datasets - Plot LSprod, echo =F}
renderPlot({terra::plot(LSprod(),
                        main="Livestock production (kg/pixel)",
                        pax=list(cex.axis=input$TextSize),
                        plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
                        col=viridis(n=length(levels(LPS_Suitable)[[1]]),
                                    option =input$Palette,
                                    direction = if(input$Palette=="turbo"){1}else{-1}),
                        cex.main = input$TextSize*1.2,
                        axes = F,
                        frame.plot= F)
          terra::plot(CGIAR_countries,add=T,border=input$BorderCol)
  },height=Plot.Height, width=Plot.Width)
```


**LS Area**
*Note that we do not have a layer for this data so cellsize is currently substituted.*
```{r Datasets - Load LSarea,echo=T}
LSareaFun<-function(CellSize.km,LSChoice){
  X<-CellSize.km
  if(length(LSChoice)>1){
  for(i in 1:length(LSChoice)){
      X<-c(X,CellSize.km)
  }
  }
  return(X)
  }

LSarea1<-reactive({
  LSareaFun(CellSize.km,input$LSChoice)
})

# Rename layers
LSarea<-reactive({
  LSfun(Data=LSarea1(),Choice=input$LSChoice,Extension="_area",TotalName="LS",DoSum=F,IncTot=input$IncTot)
})

```

```{r Datasets - Plot LSarea, echo =F}
renderPlot({terra::plot(LSarea(),
                        main="Livestock area (pixel size at present)",
                        pax=list(cex.axis=input$TextSize),
                        plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
                        col=viridis(n=length(levels(LPS_Suitable)[[1]]),
                                    option =input$Palette,
                                    direction = if(input$Palette=="turbo"){1}else{-1}),
                        cex.main = input$TextSize*1.2,
                        axes = F,
                        frame.plot= F)
          terra::plot(CGIAR_countries,add=T,border=input$BorderCol)
  },height=Plot.Height, width=Plot.Width)
```

#### Crops {.tabset .tabset-fade .tabset-pills}
**MapSPAM datasets are used for crop VoP, Yield, Total Production and Area**

MAPSPAM data can be downloaded [here](https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi:10.7910/DVN/FSSKBW) and methods reviewed [here](https://www.mapspam.info/methodology/).

Citation: *International Food Policy Research Institute, 2020, "Spatially-Disaggregated Crop Production Statistics Data in Africa South of the Sahara for 2017", https://doi.org/10.7910/DVN/FSSKBW, Harvard Dataverse, V3*

##### Value of Production (VoP)
Download VoP [here](https://dataverse.harvard.edu/file.xhtml?fileId=4271679&version=3.0).

```{r Datasets - Load MapSPAM VoP,echo=T}
MSfun<-function(VAR,TECH,CROPS,BaseRaster,MASK,MS_options,Name,IncTot){
  FILES<-MS_options[Variable == VAR & TechCode == TECH & Crop %in% CROPS,]
  
  X<-terra::rast(
    raster::readAll(
      raster::stack(
        terra::rast(
        unzip(paste0("Data/MAPSPAM/",FILES[1,Archive],".zip"),files =FILES[,Filename],overwrite = T)
        ))))
  unlink(FILES[,Filename])
  
  #X<-terra::rast(FILES[,paste0("Data/MapSPAM/",Filename)])
  
  X<-terra::resample(X,BaseRaster,method="near")
  X<-terra::mask(X,MASK)
  names(X)<-FILES[,paste0(CROPS,Name)]
  
  if(length(CROPS)>1 & IncTot=="Yes"){
    X<-c(X,sum(X))
    names(X)<-c(FILES[,paste0(CROPS,Name)],paste0("crops",Name))
  }
  return(X)
}
  
MSvop<-reactive({
    MSfun(VAR="VOP",
          TECH=MSTechCode(),
          CROPS=input$CropChoice,
          BaseRaster=BaseRaster,
          MASK=CGIAR_countries,
          MS_options=MS_options,
          Name="_vop",
          IncTot=input$IncTot)
})

```

**MapSPAM Crop Value of Production - million USD/pixel**
```{r Datasets - Plot MSvop, echo =F}
renderPlot({terra::plot(round(MSvop()/10^6,1),
                        pax=list(cex.axis=input$TextSize),
                        plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
                        col=viridis(n=length(levels(LPS_Suitable)[[1]]),
                                    option =input$Palette,
                                    direction = if(input$Palette=="turbo"){1}else{-1}),
                        cex.main = input$TextSize*1.2,
                        axes = F,
                        frame.plot= F)
            terra::plot(CGIAR_countries,add=T,border=input$BorderCol)
  },height=Plot.Height, width=Plot.Width)
```


##### Area
Download crop physical area [here](https://dataverse.harvard.edu/file.xhtml?fileId=4271676&version=3.0).
Download crop harvested area [here](https://dataverse.harvard.edu/file.xhtml?fileId=4271688&version=3.0).

```{r Datasets - MapSPAM physical area, echo=T}
MShparea<-reactive({
    MSfun(VAR="PhysArea",
          TECH=MSTechCode(),
          CROPS=input$CropChoice,
          BaseRaster=BaseRaster,
          MASK=CGIAR_countries,
          MS_options=MS_options,
          Name="_area",
          IncTot=input$IncTot)
})
```

```{r Datasets - MapSPAM harvested area, echo=T}
MSharea<-reactive({
    MSfun(VAR="HarvArea",
          TECH=MSTechCode(),
          CROPS=input$CropChoice,
          BaseRaster=BaseRaster,
          MASK=CGIAR_countries,
          MS_options=MS_options,
          Name="_area",
          IncTot=input$IncTot)
})
```

```{r Set Area Type to be used in analysis,echo=T}
MSarea<-reactive({
  if(input$MSAreaType=="Physical"){
     MShparea()
  }else{
    MSharea()
  }
})
```

**MapSPAM crop physical area - ha/pixel**
```{r Datasets - Plot MShparea, echo = F}
renderPlot({terra::plot(MShparea(),
                        pax=list(cex.axis=input$TextSize),
                        plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
                        col=viridis(n=length(levels(LPS_Suitable)[[1]]),
                                    option =input$Palette,
                                    direction = if(input$Palette=="turbo"){1}else{-1}),
                        cex.main = input$TextSize*1.2,
                        axes = F,
                        frame.plot= F)
            terra::plot(CGIAR_countries,add=T,border=input$BorderCol)
  },height=Plot.Height, width=Plot.Width)
```

**MapSPAM crop harvested area - ha/pixel**
```{r Datasets - Plot MSharea, echo = F}
renderPlot({terra::plot(MSharea(),
                        pax=list(cex.axis=input$TextSize),
                        plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
                        col=viridis(n=length(levels(LPS_Suitable)[[1]]),
                                    option =input$Palette,
                                    direction = if(input$Palette=="turbo"){1}else{-1}),
                        cex.main = input$TextSize*1.2,
                        axes = F,
                        frame.plot= F)
            terra::plot(CGIAR_countries,add=T,border=input$BorderCol)
  },height=Plot.Height, width=Plot.Width)
```

##### Production
Download crop production volume [here](https://dataverse.harvard.edu/file.xhtml?fileId=4271677&version=3.0).

```{r Datasets - MapSPAM crop production, echo=T}
MSprod<-reactive({
    MSfun(VAR="Production",
          TECH=MSTechCode(),
          CROPS=input$CropChoice,
          BaseRaster=BaseRaster,
          MASK=CGIAR_countries,
          MS_options=MS_options,
          Name="_prod",
          IncTot=input$IncTot)
})
```

**MapSPAM Production - ????/pixel**
```{r Datasets - Plot MSprod, echo = F}
renderPlot({terra::plot(MSprod(),
                        pax=list(cex.axis=input$TextSize),
                        plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
                        col=viridis(n=length(levels(LPS_Suitable)[[1]]),
                                    option =input$Palette,
                                    direction = if(input$Palette=="turbo"){1}else{-1}),
                        cex.main = input$TextSize*1.2,
                        axes = F,
                        frame.plot= F)
            terra::plot(CGIAR_countries,add=T,border=input$BorderCol)
  },height=Plot.Height, width=Plot.Width)
```


#### FAOSTAT
```{r Datasets - Load FAOSTAT, echo=T}
FAODir<-"Data/FAO"
FAOFile<-paste0(FAODir,"/FAO_prod.RData")

if(!file.exists(FAOFile)){
if(!dir.exists(FAODir)){
  dir.create(FAODir)
}
  
fao_metadata<-FAOSTAT::FAOsearch()
#FAOSTAT::FAOsearch(dataset="crop",full=FALSE)
FAO_prod<-data.table(FAOSTAT::get_faostat_bulk(code="QCL",data_folder=FAODir))

UpdateFAOCountries<-data.table(
  FAO=c("Bolivia (Plurinational State of)","Iran (Islamic Republic of)","Syrian Arab Republic","Congo","Viet Nam","Lao People's Democratic Republic","Côte d'Ivoire","Timor-Leste","Brunei Darussalam","Eswatini","Venezuela (Bolivarian Republic of)","Bahamas","United Republic of Tanzania"),
  CGIAR=c("Bolivia","Iran","Syria","Republic of the Congo","Vietnam","Laos","Cote d'Ivoire","East Timor","Brunei","eSwatini","Venezuela","The Bahamas","Tanzania")
)

# Match then update FAO names with CGIAR names
N<-match(FAO_prod[,area],UpdateFAOCountries[,FAO])

FAO_prod[which(!is.na(N)),area:=UpdateFAOCountries[N[!is.na(N)],CGIAR]]
FAO_prod<-FAO_prod[area %in% CGIAR_countries$ADMIN]

save(FAO_prod,file=FAOFile)

# Remove downloaded zip file
unlink("Data/FAO/Production_Crops_Livestock_E_All_Data_(Normalized).zip")

}else{
  FAO_prod<-miceadds::load.Rdata2(FAOFile)
}

FAO_prod<-FAO_prod[element %in% c("yield","milk_animals","yield_carcass_weight") & !is.na(value) & year %in% 2001:2020]

# Convert hg/ha to t/ha
FAO_prod[,value:=as.numeric(value)
         ][unit=="hg/ha",value:=value*0.0001
           ][unit=="hg/ha",unit:="t/ha"]
```

**Calculate coefficient of variation**
```{r Datasets - FAOSTAT calculate CV,echo=T}
FAO_CV<-FAO_prod[,list(Mean=mean(value),
                       SD=sd(value),
                       CV=100*(sd(value)/mean(value)),
                       N.Years=.N),by=list(area,item,element,unit)]
```

**Map FAO names to MapSPAM**
```{r Datasets -  Map FAO names to MapSPAM,echo=T}
MSCrops<-MS_options[,unique(Crop)]
FAOCrops<-FAO_CV[,tolower(unique(item))]

CropMatch<-MSCrops[MSCrops %in% FAOCrops]
CropNoMatch<-MSCrops[!MSCrops %in% FAOCrops]

CropMappings<-data.table(MapSPAM=MSCrops,FAO=as.character(NA))
CropMappings[MapSPAM %in% FAOCrops,FAO:=MapSPAM]

CropMappings[MapSPAM=="arabica coffee",FAO:="coffee, green"]
CropMappings[MapSPAM=="banana",FAO:="bananas"]
CropMappings[MapSPAM=="bean",FAO:="beans, dry"]
CropMappings[MapSPAM=="chickpea",FAO:="chick peas"]
CropMappings[MapSPAM=="coconut",FAO:="coconuts"]
CropMappings[MapSPAM=="cocoa",FAO:="cocoa, beans"]
CropMappings[MapSPAM=="cotton",FAO:="seed cotton"]
CropMappings[MapSPAM=="cowpea",FAO:="cow peas, dry" ]
CropMappings[MapSPAM=="groundnut",FAO:="groundnuts, with shell"]
CropMappings[MapSPAM=="lentil",FAO:="lentils"]
CropMappings[MapSPAM=="other cereals",FAO:="cereals nes"]
CropMappings[MapSPAM=="other fibre crops",FAO:="fibre crops nes"]
CropMappings[MapSPAM=="oilpalm",FAO:="oil palm fruit"]
CropMappings[MapSPAM=="other oil crops",FAO:="oilseeds nes"]
CropMappings[MapSPAM=="other pulses",FAO:="pulses nes"]
CropMappings[MapSPAM=="other roots",FAO:="roots and tubers nes"]
CropMappings[MapSPAM=="pigeonpea",FAO:="pigeons peas"]
CropMappings[MapSPAM=="plantain",FAO:="plantains and others"]
CropMappings[MapSPAM=="pearl millet",FAO:="millet"]
CropMappings[MapSPAM=="potato",FAO:="potatoes"]
CropMappings[MapSPAM=="robusta coffee",FAO:=NA]
CropMappings[MapSPAM=="rest of crops",FAO:=NA]
CropMappings[MapSPAM=="rice",FAO:="rice, paddy"]
CropMappings[MapSPAM=="sesameseed",FAO:="sesame seed"]
CropMappings[MapSPAM=="small millet",FAO:=NA]
CropMappings[MapSPAM=="soybean",FAO:="soybeans"]
CropMappings[MapSPAM=="sugarbeet",FAO:="sugar beet"]
CropMappings[MapSPAM=="sugarcane",FAO:="sugar cane"]
CropMappings[MapSPAM=="sunflower",FAO:="sunflower seed"]
CropMappings[MapSPAM=="sweet potato",FAO:="sweet potatoes"]
CropMappings[MapSPAM=="temperate fruit",FAO:=NA]
CropMappings[MapSPAM=="tropical fruit",FAO:="fruit, tropical fresh nes"]
CropMappings[MapSPAM=="vegetables",FAO:="vegetables primary"]
CropMappings[MapSPAM=="tobacco",FAO:="tobacco, unmanufactured"]

FAO_CV[,SpamName:=CropMappings[match(tolower(FAO_CV$item),CropMappings$FAO),MapSPAM]]
FAO_CV<-FAO_CV[!is.na(SpamName)]

```

```{r Datasets - FAOSTAT DT, echo=F}
  renderDT({
    datatable(dplyr::mutate_if(FAO_CV,is.numeric,~round(.,3)),
                caption="",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  })
```

#### Human population
*Not currently used in the analysis*
**--add dataset details--**
**CHECK resampling method = "near" is correct**
```{r Datasets - Load Hpop, echo = T}
# Load and resample raster
Hpop<-terra::resample(terra::rast(unzip("Data/Exposure/cell5m_ruralpop_2020_v3.zip")),BaseRaster,method="near")
# Force raster into memory 
if(sources(Hpop)$source!=""){
  Hpop<-terra::rast(raster::readAll(raster::raster(Hpop)))
}
# Remove unzipped file
unlink("cell5m_ruralpop_2020_v3.tif")
# Mask raster to CGIAR countries
Hpop<-terra::mask(Hpop,CGIAR_countries)
# Name raster
names(Hpop)<-"Hpop"
```

```{r Datasets - Plot Hpop, echo = F}
renderPlot({terra::plot(Hpop,
                        pax=list(cex.axis=input$TextSize),
                        plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
                        col=viridis(n=length(levels(LPS_Suitable)[[1]]),
                                    option =input$Palette,
                                    direction = if(input$Palette=="turbo"){1}else{-1}),
                        cex.main = input$TextSize*1.2,
                        axes = F,
                        frame.plot= F)
            terra::plot(CGIAR_countries,add=T,border=input$BorderCol)
  },height=Plot.Height, width=Plot.Width)
```

#### Climate hazards
*Not currently used in the analysis*
**--add dataset details--**

```{r Datasets - Load climate hazards, echo = T}
RainCV<-terra::resample(terra::rast("Data/Hazards/chirps_cv.tif"),BaseRaster,method="near")
RainCV<-terra::mask(RainCV,CGIAR_countries)
names(RainCV)<-"RainCV"

```

```{r Datasets - Plot RainCV, echo = F}
renderPlot({terra::plot(RainCV,
                        pax=list(cex.axis=input$TextSize),
                        plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
                        col=viridis(n=length(levels(LPS_Suitable)[[1]]),
                                    option =input$Palette,
                                    direction = if(input$Palette=="turbo"){1}else{-1}),
                        cex.main = input$TextSize*1.2,
                        axes = F,
                        frame.plot= F)
            terra::plot(CGIAR_countries,add=T,border=input$BorderCol)
  },height=Plot.Height, width=Plot.Width)
```


#### Stack
```{r Datasets - Stack datasets,echo=T}
# Raster stacked
Stacked<-reactive({
  c(LPS_Suitable,
    LSvop(),
    LSprod(),
    MSvop(),
    MSarea(),
    MSprod(),
    Hpop,
    RainCV)
})

# Columns to sum
SumCols<-reactive({
  c(names(Stacked())[!names(Stacked()) %in% c("LPS_Suitable","CellSize","RainCV")],"CellSize.km")
})

# Columns to analyse
prod_cols<-reactive({names(MSprod())})
area_cols<-reactive({names(MSarea())})
vop_cols<-reactive({names(MSvop())})
vop_cols_LS<-reactive({names(LSvop())})
```

### Analysis {.tabset .tabset-fade .tabset-pills}
**Set analysis parameters**  

:::: {style="display: flex;"}
::: {}

*.*  
*.*  
*.*

:::: {style="display: flex;"}
::: {}
```{r Parameter - Timeframe,echo=F}
  numericInput(inputId="Years", 
              label="Duration (years)",
              value = 1,
              min=1, 
              max=50,
              step = 1,
              width="120px")
```
:::
:::{}
```{r Parameter - Cost Factor,echo=F}
  numericInput(inputId="CostFactor", 
              label="Cost factor",
              value = 2.5,
              min=0,              
              max=10,
              step = 0.1,
              width="100px")
```
:::
::::

:::
:::{}

**Annual productivity increments (PIs)**  
*1-3 values can be entered.*  
*Enter value as a percentage (%)*

:::: {style="display: flex;"}
::: {}
```{r Parameter - Productivity Increment 1,echo=F}
  numericInput(inputId="PI_1", 
              label="PI Value 1",
              value = 5,
              min=0,              
              max=100,
              step = 1,
              width="100px")
```
:::
:::{}
```{r Parameter - Productivity Increment 2,echo=F}
  numericInput(inputId="PI_2", 
              label="PI Value 2",
              value = 10,
              min=0,              
              max=100,
              step = 1,
              width="100px")
```
:::
:::{}
```{r Parameter - Productivity Increment 3,echo=F}
  numericInput(inputId="PI_3", 
              label="PI Value 3",
              value = NULL,
              min=0,              
              max=100,
              step = 1,
              width="100px")
```
:::
::::

:::
:::{}

**Annual adoption rates (AARs) in core areas**  
*1-3 values can be entered.*  
*Enter value as a percentage (%   )*

:::: {style="display: flex;"}
::: {}
```{r Parameter - Core Adoption Rate 1,echo=F}
  numericInput(inputId="CAAR_1", 
              label="AAR Value 1",
              value = 1,
              min=0,              
              max=100,
              step = 1,
              width="100px")
```
:::
:::{}
```{r Parameter - Core Adoption Rate 2,echo=F}
  numericInput(inputId="CAAR_2", 
              label="AAR Value 2",
              value = 2,
              min=0,              
              max=100,
              step = 1,
              width="100px")
```
:::
:::{}
```{r Parameter - Core Adoption Rate 3,echo=F}
  numericInput(inputId="CAAR_3", 
              label="AAR Value 3",
              value = 3,
              min=0,              
              max=100,
              step = 1,
              width="100px")
```
:::
::::

:::
:::{}

**Spillover factor**  
*The spillover of adoption from core to*  
*spillover countries as a percentage (%)*  
```{r Parameter - Spillover Factor,echo=F}
  numericInput(inputId="SpillFactor", 
              label="Spillover",
              value = 1,
              min=0,              
              max=100,
              step = 1,
              width="100px")
```

:::
::::

```{r Parameters - Combine PIs & AARS,echo=F}
Pr.Inc<-reactive({
  c(input$PI_1,input$PI_2,input$PI_3)[!is.na(c(input$PI_1,input$PI_2,input$PI_3))]/100
})

Ad.Rates.Core<-reactive({
  c(input$CAAR_1,input$CAAR_2,input$CAAR_3)[!is.na(c(input$CAAR_1,input$CAAR_2,input$CAAR_3))]/100
})

Ad.Rates.Spillover<-reactive({
  Ad.Rates.Core()*(input$SpillFactor/100)
})
```

:::: {style="display: flex;"}
::: {}
```{r Parameter - CV reduction amount,echo=F}
  numericInput(inputId="CV_Change", 
              label="CV reduction",
              value = 5,
              min=0,              
              max=100,
              step = 1,
              width="100px")
```
:::
:::{}
```{r Parameter - Discount Rate,echo=F}
  numericInput(inputId="DiscountRate1", 
              label="Discount rate (%)",
              value = 5,
              min=0,              
              max=100,
              step = 1,
              width="120px")

DiscountRate<-reactive({input$DiscountRate1/100})
```
:::
:::{}
```{r Parameter - Project Cost,echo=F}
  numericInput(inputId="ProjectCost1", 
              label="Project cost (million USD)",
              value = 60,
              min=0,              
              max=10000,
              step = 5,
              width="200px")

ProjectCost<-reactive({input$ProjectCost1*10^6})
```
:::
::::

#### Prepare functions & names
Create function to extract and summarize variables by LPS x Country:
```{r Extraction - Function to extract and summarize variables by LPS x Country,echo=T}
StackExtractor1<-function(Data,ExtractBy,SumCols,prod_cols,area_cols,vop_cols){

  Stacked<-lapply(1:length(ExtractBy),FUN=function(i){
    X<-ExtractBy[i]
    Y<-terra::mask(terra::crop(Data,X),X)
    Y$CellSize.km<-terra::cellSize(Y[[1]],mask=T, unit="km")
    Y
  })
  names(Stacked)<-ExtractBy$ADMIN

  # Extract other variables by LPS
  Stats<-rbindlist(lapply(1:length(Stacked),FUN=function(i){
    X<-Stacked[[i]]
    Stats<-terra::zonal(X[[SumCols]],X[["LPS_Suitable"]],fun=sum,na.rm=T)
    colnames(Stats)[colnames(Stats)=="CellSize.km"]<-"Area.km2"
    Stats$RainCV.ln<-log(zonal(X[["RainCV"]],X[["LPS_Suitable"]],fun=mean,na.rm=T)$RainCV)
    Stats$Country<-names(Stacked)[i]
    Stats
    }))
  
yields<-Stats[,..prod_cols]/Stats[,..area_cols]
colnames(yields)<-gsub("_prod","_yield",colnames(yields))

prices<-Stats[,..vop_cols]/Stats[,..prod_cols]
colnames(prices)<-gsub("_vop","_price",colnames(prices))

Stats<-cbind(Stats,yields,prices)

return(Stats)
}
```

Create function to calculate value of an annual increment in productivity:
```{r Analysis - Create AnnIncFun,echo=T}
# Annual Increase 
AnnIncFun<-function(Stats.Core,vop_cols,vop_cols_LS,Pr.Inc){
  Cols<-c("LPS_Suitable","Country",vop_cols,vop_cols_LS)
  AnnualInc.Core<-Stats.Core[,..Cols]
  
  AnnualInc.Core<-melt(AnnualInc.Core,id.vars = c("LPS_Suitable","Country"),variable.name = "Crop",value.name = "VOP")
  
  AnnualInc.Core<-AnnualInc.Core[,LPS_Code:=paste(substr(unlist(strsplit(LPS_Suitable[1] ," ")),1,1),collapse=""),by=LPS_Suitable]
  
  AnnualInc.Core<-AnnualInc.Core[,list(LPS=paste(sort(unique(LPS_Code)),collapse=", "),VOP=sum(VOP,na.rm=T)),by=list(Country,Crop)
                 ][,Crop:=gsub("_vop","",Crop)
                   ][,Country_LPS:=paste0(Country,"\n(",LPS,")")]
  
  AnnualInc.Core<-dcast(AnnualInc.Core,Crop~Country_LPS,value.var = "VOP")
  AnnualInc.Core[,Total:=rowSums(AnnualInc.Core[,-1])]
  AnnualInc.Core<-rbind(AnnualInc.Core,data.table("Total",t(colSums(AnnualInc.Core[!Crop %in% c("LS","crops"),-1]))),use.names=F)
  
  AnnualInc.Core<-data.table(System=AnnualInc.Core[,Crop],AnnualInc.Core[,-1]*Pr.Inc)
  
  return(AnnualInc.Core)
}

```

Create function to calculate marginal increase in value of production (VoP):
```{r Analysis - Marginal Increase,echo=T}
MarginalInc<-function(Ad.Rate,Pr.Inc,Years,Yield,Area,Price,VOP,CostFactor){

  Data<-data.table(Y_non_adopt=Yield,
             Y_adopt=Yield*(1+Pr.Inc),
             Year=1:Years
             )

  Total_Adoption<-Ad.Rate

  for(i in 2:Years){
    Total_Adoption[i]<-(1-sum(Total_Adoption))*Ad.Rate
  }

  Data[,Price:=Price][,Total_Adoption:=cumsum(Total_Adoption)
       ][,A_non_adopt:=Area*(1-Total_Adoption)
         ][,A_adopt:=Area*Total_Adoption
           ][,VOP_non:=A_non_adopt*Y_non_adopt*Price
             ][,VOP_adopt:=A_adopt*Y_adopt*Price
               ][,Marginal_VOP:=VOP_adopt*(Y_adopt-Y_non_adopt)/CostFactor
                 ][,Total_VOP:=VOP_non+VOP_adopt
                   ]
  
  return(Data)

}

```

Create wrapper function for marginal increase in VoP which restructures data for analysis:
```{r Analysis - Marginal increase wrapper,echo=T}
MIwrapper<-function(Data,Ad.Rates,Pr.Inc,Years,System,CostFactor){

  ValCols<-paste0(rep(System,each=4),c("_vop","_yield","_price","_area"))

  Cols<-c(ValCols,"LPS_Suitable","Country","Area.km2")
  Stats2<-melt(Data[,..Cols],id.vars = c("Country","LPS_Suitable","Area.km2"),value.name = "StartVal",variable.name = "System")
  Stats2[,Crop:=tstrsplit(System,"_",keep=1)
         ][,Variable:=tstrsplit(System,"_",keep=2)][,System:=NULL]

  Stats2<-dcast(Stats2,Country+LPS_Suitable+Area.km2+Crop~Variable,value.var = "StartVal")

  MI.args<-data.table(expand.grid(Ad.Rate=Ad.Rates,Pr.Inc=Pr.Inc))

  N1<-rep(1:nrow(MI.args),each=nrow(Stats2))
  N2<-rep(1:nrow(Stats2),nrow(MI.args))

  Stats2<-data.table(Stats2[N2],MI.args[N1])

  rm(N1,N2,MI.args)

  Stats.Marg<-Stats2[,MarginalInc(Ad.Rate=Ad.Rate,
                                  Pr.Inc=Pr.Inc,
                                  Years=10,
                                  Yield=yield,
                                  Area=area,
                                  Price=price,
                                  VOP=vop,
                                  CostFactor=CostFactor),
                     by=list(LPS_Suitable,Country,Crop,Area.km2,Ad.Rate,Pr.Inc)]
  return(Stats.Marg)
}
```

Create function to calculate avoided yield loss from a reduction in yield variability (CV):
```{r Analysis - Avoided loss function, echo=T}
AvLoss<-function(Mean,SD,Change,Fixed,Reps=100000){
  #Calculate co-efficient of variation

  # Calculate new standard deviation based on changed CV
  if(Fixed){
   SDcis<-((SD/Mean)-(Change/100))*Mean
  }else{
    SDcis<-((SD/Mean)*(1-(Change/100)))*Mean
  }

  if(!SDcis<=0){

  # Create normal distribution of values
  X<-rnorm(n=Reps,mean=Mean,sd=SD)
  # Calculate probabilities
  Pnorm<-pnorm(X,mean=Mean,sd=SD)
  PnormCIS<-pnorm(X,mean=Mean,sd=SDcis)

  # Calculate differences in probabilities
  PnormDiff<-PnormCIS-Pnorm

  # Sum negative differences and divide by total probability for normal CV
  AVLoss<-100*(sum(PnormDiff[PnormDiff<0])/sum(Pnorm))
  }else{
    AVLoss<-NA
  }
  
return(AVLoss)
}
```

Create wrapper function for avoided yield loss which recalculates marginal benefits:
```{r Analysis - Avoided Loss Wrapper, echo=T}
AvLossWrapper<-function(CV_Data,Stats,CV_Change,CostFactor){
  CV_Data[,CVfixed:=CV-CV_Change
            ][,AvoidedLossFixed:=AvLoss(Mean=Mean,SD=SD,Change=CV_Change,Fixed=T),by=list(area,item)
              ][,AvoidedLossProp:=AvLoss(Mean=Mean,SD=SD,Change=CV_Change,Fixed=F),by=list(area,item)]
  N<-match(
    Stats[,paste(Country,Crop)],
    CV_Data[,paste(area,SpamName)]
  )
  
  Stats[,AvoidedLossFixed:=CV_Data[N,AvoidedLossFixed]
          ][,Marginal_VOP_CIS:=(((100-AvoidedLossFixed)/100)*Y_adopt*A_adopt*Price-VOP_adopt)/CostFactor
            ][,Marginal_VOP_Both:=Marginal_VOP_CIS+Marginal_VOP]
  
  return(list(Stats=Stats,CV_Data=CV_Data))
}
```

Create function to calculate Internal Rate of Return (IRR):
```{r Analysis - IRR function,echo=T}
irr <- function(x, period = 1, starting.value = .1){

  ### This should detect the number of sign changes.  Should correctly not warn if there are many negative cash flows (so long as there is only 1 change in sign).

  irr.func <- function(r){ ( sum(x / (1 + r)^{0:(length(x)-1)}) )^2 }
  result <- optim(par = starting.value, fn = irr.func, method = "Brent", lower = -1000000, upper = 1000000)

  ## detecting number of sign changes
  x.ge.0 <- 1 * (x >= 0)
  changes <- diff(x.ge.0)
  changes <- changes * changes
  num.changes <- sum(changes)

  if( num.changes > 1) {

    statement <- "Your cash flows change more than once -- so you may have multiple IRRs. This function will only return the first IRR it finds. To find the others, you can try different starting values.  However, note the IRR does not make sense if the signs change more than once (try Modified IRR or NPV)."
    value <- period * result$par
    return(list(beware = statement, IRR = value))

  } else {

    return(list(IRR = period * result$par))

  }
}
```
*The above function is adapted from [this stackoverflow post](https://stackoverflow.com/questions/29781785/computing-irr-using-optim)*

Create wrapper function for IRR calculations:
```{r Analysis - IRR wrapper function,echo=T}
irr_wrapper<-function(NPV,InvestData,ProjectCost){
  X<-InvestData[,list(Value=sum(VOP,na.rm=T)),by=list(Ad.Rate,Pr.Inc,Year,NPVtype)]
  Y<-X[,list(IRR=irr(c(-ProjectCost,Value),starting.value=0.1)),by=list(Ad.Rate,Pr.Inc,NPVtype)]
  return(data.table(NPV,IRR=as.numeric(Y[,IRR])))
}
```

#### Extract Data
**Core countries**
```{r Extraction - Core countries,echo=T}
Stats.Core<-reactive({
  StackExtractor1(Data=Stacked(), 
                  ExtractBy = ExtractBy.Core(), 
                  SumCols=SumCols(),
                  prod_cols=prod_cols(),
                  area_cols=area_cols(),
                  vop_cols=vop_cols())
})


```

```{r Extraction - Core countries DT, echo=F}
  renderDT({
    datatable(dplyr::mutate_if(Stats.Core(),is.numeric,~round(.,3)),
                caption="",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  })
```

**Spillover countries**
```{r Extraction - Spillover countries,echo=T}
Stats.Spillover<-reactive({
  StackExtractor1(Data=Stacked(), 
                  ExtractBy = ExtractBy.Spillover(), 
                  SumCols=SumCols(),
                  prod_cols=prod_cols(),
                  area_cols=area_cols(),
                  vop_cols=vop_cols())
})


```

```{r Extraction - Spillover countries DT, echo=F}
  renderDT({
    datatable(dplyr::mutate_if(Stats.Spillover(),is.numeric,~round(.,3)),
                caption="",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  })
```


#### Productivity increment value
The estimated direct benefits of adoption of CSA practices in the selected core countries, expressed as the increase in value (USD) of production per year per the specified percentage productivity increment in crop, meat or milk yields – that is, assuming adoption over all the crop area and all cattle in the target systems of a technology that increased production per ha or per animal by the specified percentages.

:::: {style="display: flex;"}
::: {}
```{r Parameter - Annual increment,echo=F}
  numericInput(inputId="AI_PrInc1", 
              label="Productivity increment (%)",
              value = 1,
              min=0,              
              max=100,
              step = 1,
              width="200px")

AI_PrInc<-reactive({input$AI_PrInc1/100})
```
:::
:::{}
```{r Parameter - Annual increment - units,echo=F}
selectInput(inputId="AI_Units", 
            label="Divide USD by:",
            choices = c(1,10,100,1000,10000,100000,1000000), 
            selected = 1,
            multiple = F,
            width="150px")

```
:::
::::

```{r Analysis - Annual Increment,echo=T}
AnnInc<-reactive({
  AnnIncFun(Stats.Core=Stats.Core(),
                  vop_cols=vop_cols(),
                  vop_cols_LS=vop_cols_LS(),
                  Pr.Inc=AI_PrInc())
})

```

```{r Analysis - Annual Increment DT,echo=F}
  renderDT({
    datatable(dplyr::mutate_if(AnnInc(),is.numeric,~round(./as.numeric(input$AI_Units),1)),
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  })
```

#### Marginal increase in value
**Core countries**
```{r Analysis - MI Core, echo=T}
MI.Core<-reactive({
  MIwrapper(Data=Stats.Core(),
          Ad.Rates=Ad.Rates.Core(),
          Pr.Inc=Pr.Inc(),
          Years=input$Years,
          System=input$CropChoice,
          CostFactor=input$CostFactor)
})

```

```{r Analysis - MI Core DT, echo=F}
  renderDT({
    datatable(dplyr::mutate_if(MI.Core(),is.numeric,~round(.,3)),
                caption="",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  })
```

**Spillover countries**
```{r Analysis - MI Spillover, echo = T}
MI.Spillover<-reactive({
  MIwrapper(Data=Stats.Spillover(),
                         Ad.Rates=Ad.Rates.Spillover(),
                         Pr.Inc=Pr.Inc(),
                         Years=input$Years,
                         System=input$CropChoice,
                         CostFactor=input$CostFactor)
})
```

```{r Analysis - MI Spillover DT, echo=F}
  renderDT({
    datatable(dplyr::mutate_if(MI.Spillover(),is.numeric,~round(.,3)),
                caption="",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  })
```

#### Avoided losses from reduction in CV
*Note that this analysis is for crops only*
```{r Analysis - CV Subset data to crops,echo=T}
CV_Subset_Core<-reactive({
  FAO_CV[area %in% input$CountriesChoice & SpamName %in% input$CropChoice]
})

CV_Subset_Spill<-reactive({
  FAO_CV[area %in% input$SpillCountriesChoice & SpamName %in% input$CropChoice]
})

```

**Core avoided losses**
```{r Analysis - Core avoided losses,echo=T}
CoreCV<-reactive({
  AvLossWrapper(CV_Data=CV_Subset_Core(),
                Stats=MI.Core(),
                CV_Change=input$CV_Change,
                CostFactor=input$CostFactor)
})

```

```{r Analysis -  Core avoided losses DT CV_Data, echo=F}
  renderDT({
    datatable(dplyr::mutate_if(CoreCV()$CV_Data,is.numeric,~round(.,3)),
                caption="",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  })
```

```{r Analysis -  Core avoided losses DT Stats, echo=F}
  renderDT({
    datatable(dplyr::mutate_if(CoreCV()$Stats,is.numeric,~round(.,3)),
                caption="",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  })
```

**Spillover avoided losses**
```{r Analysis - Spillover avoided losses,echo=T}
SpilloverCV<-reactive({
  AvLossWrapper(CV_Data=CV_Subset_Spill(),
                Stats=MI.Spillover(),
                CV_Change=input$CV_Change,
                CostFactor=input$CostFactor)
})

```

```{r Analysis -  Spillover avoided losses DT CV_Data, echo=F}
  renderDT({
    datatable(dplyr::mutate_if(SpilloverCV()$CV_Data,is.numeric,~round(.,3)),
                caption="",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  })
```

```{r Analysis -  Spillover avoided losses DT Stats, echo=F}

  renderDT({
    datatable(dplyr::mutate_if(SpilloverCV()$Stats,is.numeric,~round(.,3)),
                caption="",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  })
```

#### Investment indicators  {.tabset .tabset-fade .tabset-pills}
##### Net Present Value (NPV) & Benefit-cost Ratio (BCR)
**Core**
```{r Analysis - NPV Calc 1,echo=T}
InvestStatCrops<-"maize"

InvestData1<-reactive({
  CoreCV()$Stats[Crop %in% InvestStatCrops, list(LPS_Suitable,Country,Crop,Ad.Rate, Pr.Inc, Marginal_VOP_Both, Marginal_VOP, Year, Total_Adoption, AvoidedLossFixed)
                    ][,NPVboth:=Marginal_VOP_Both/(1+DiscountRate())^Year
                      ][,NPVcsa:=Marginal_VOP/(1+DiscountRate())^Year]
})

InvestData<-reactive({
  melt(InvestData1(),
     id.vars = c("LPS_Suitable","Country","Crop","Ad.Rate", "Pr.Inc", "Year", "Total_Adoption", "AvoidedLossFixed", "Marginal_VOP_Both", "Marginal_VOP"),
     variable.name = "NPVtype",
     value.name = "NPV")[,VOP:=Marginal_VOP
                         ][,Marginal_VOP:=NULL
                           ][NPVtype=="NPVboth",VOP:=Marginal_VOP_Both
                             ][,Marginal_VOP_Both:=NULL]
})
```

```{r Analysis - NPV Calc 1 DT, echo=F}

  renderDT({
    datatable(dplyr::mutate_if(InvestData(),is.numeric,~round(.,3)),
                caption="",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  })
```

```{r Analysis - NPV Calc 2,echo=T}

NPV<-reactive({
  InvestData()[,list(Avoided_loss_mean=-mean(AvoidedLossFixed,na.rm=T)/100,
                      Value=sum(NPV,na.rm=T),
                      Years=length(unique(Year)),
                      Implied_Adoption=max(Total_Adoption)
                      ),by=list(Ad.Rate,Pr.Inc,NPVtype)
             ][,NPV:=Value-ProjectCost()
               ][,BCR:=NPV/ProjectCost()
                 ][,Value:=NULL]
})

```

```{r Analysis - NPV Calc 2 DT, echo=F}
  renderDT({
    datatable(dplyr::mutate_if(NPV(),is.numeric,~round(.,3)),
                caption="",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  })
```

##### Internal Rate of Return (IRR) 
```{r Analysis - IRR Calc,echo=T}

InvestStats_IRR<-reactive({
  irr_wrapper(NPV=NPV(),
              InvestData=InvestData(),
              ProjectCost=ProjectCost())
})
```

```{r Analysis - IRR Calc DT, echo=F}
  renderDT({
    datatable(dplyr::mutate_if(InvestStats_IRR(),is.numeric,~round(.,3)),
                caption="",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  })
```

