---
title: "AICCRA - EFA"
author: "Peter Steward"
date: "5/12/2022"
output: html_notebook
runtime: shiny
---
<style type="text/css">
.main-container {
  max-width: 1800px;
  margin-left: auto;
  margin-right: auto;
}
</style>
  
```{r Setup, include=FALSE}
knitr::opts_knit$set(root.dir = "C:/Users/Peter Steward/OneDrive - CGIAR/Projects/AICCRA/AICCRA_EFA")
#knitr::opts_knit$set(root.dir = getwd())
knitr::opts_chunk$set(echo = F)
```

```{r Setup - load packages,echo=F,message=FALSE}
if(!require("pacman", character.only = TRUE)){install.packages("pacman",dependencies = T)}

required.packages <- c("colourpicker",
                       "data.table",
                       "dplyr",
                       "DT",
                       "FAOSTAT",
                       "jrvFinance",
                       "raster",
                       "RJSONIO",
                       "terra",
                       "shiny",
                       "sf",
                       "viridis")

pacman::p_load(char=required.packages,install = T,character.only = T)

options(scipen = 999)
```

```{r Setup - source functions,echo=F,message=FALSE}
source("EFA functions.R")
```

## AICCRA - Economic and Financial Analysis Tool (EFAt) {.tabset .tabset-fade .tabset-pills}

**Plotting Parameters**

:::: {style="display: flex;"}
::: {}
```{r Plot - Palette,echo=F}
  selectInput(inputId="Palette", 
              label="Fill palette",
              choices = c("magma","inferno","plasma","viridis","cividis","rocket","mako","turbo"),
              selected="turbo", 
              multiple = F,
              width="100px")
```
:::
:::{}
```{r Plot - Text size,echo=F}
  numericInput(inputId="TextSize", 
              label="Text size",
              value = 1.2,
              min=1, 
              max=20,
              step = 0.1,
              width="100px")
```
:::
:::{}
```{r Plot - Base width,echo=F}
  numericInput(inputId="PlotBaseWidth", 
              label="Plot width (px)",
              value = 1200,
              min=100, 
              max=5000,
              step = 100,
              width="150px")
```
:::
:::{}
```{r  Plot - Adjust height, echo=F}
numericInput(inputId="Plot.Height",
             label="Adjust height",
             value=0.5,
             min=0.1,
             max=3,
             step=0.1, 
             width="120px")
```
:::
:::{}
```{r Plot - Adjust width , echo=F}
numericInput(inputId="Plot.Width",
             label="Adjust width",
             value=1,
             min=0.1,
             max=3,
             step=0.1,
             width="120px")
```
:::
:::{}
```{r  Plot - Legend position,echo=F}
  selectInput(inputId="LegPos", 
              label="Legend position (factors only)",
              choices = c("bottomright", "bottom", "bottomleft", "left", "topleft", "top", "topright", "right","center"),
              selected="bottomleft", 
              multiple = F,
              width="250px")
```
:::
:::{}
```{r  Plot - Legend columns,echo=F}
  numericInput(inputId="LegCols", 
              label="Legend columns",
              value = 2,
              min=1, 
              max=20,
              step = 1,
              width="130px")
```
:::
:::{}
```{r Plot - Border width , echo=F}
numericInput(inputId="borderwidth",
             label="Border width",
             value=2,
             min=0.1,
             max=3,
             step=0.1,
             width="120px")
```

:::
:::{}
```{r Plot - log plots , echo=F}
selectInput(inputId="log_plots", 
            label="Log plot values?",
            choices = c("Yes", "No"),
            selected="No", 
            multiple = F,
            width="160px")
```
:::
::::

:::: {style="display: flex;"}
::: {}
```{r Plot - Polygon boundary colour picker core, echo =F}
  colourInput(inputId="BorderColCore",
              label="Core country border colour",
              value="#000000")
```
:::
:::{}
```{r Plot - Polygon boundary colour picker spill, echo =F}
  colourInput(inputId="BorderColSpill",
              label="Spillover country border colour",
              value="#000000")
```
:::
::::

```{r Plot - Create bar height and width functions, echo=F}
  Plot.Height <- function(){input$PlotBaseWidth*input$Plot.Height}
  Plot.Width <- function(){input$PlotBaseWidth*input$Plot.Width}
```

### Approach

This economic and financial analysis (EFA) of project benefits is designed to explore:  

* Increased productivity and enhanced climate resilience (reduced production variability) of technology adoption
* More widespread adoption of CSA technologies due to regional spillovers.  

*Caveat: These benefits fall under the sphere of influence of the Project, but not under the sphere of control, because they depend in part on factors beyond the control of the Project (e.g., price incentives, availability of purchased inputs, weather conditions, etc.).*

The EFA is carried out in several stages:  

1. **Datasets tab:** Choose the core and spillover countries that will benefit from project activities;  
2. **Datasets tab:** Choose farm classification system and target classes; 
3. **Datasets tab:** Choose target crops, type of MapSPAM cropping system (e.g. rainfed, irrigated or all) and type of MapSPAM area statistic (physical area or harvested area);
4. **Datasets tab:** Choose target Herrero livestock categories;
5. **Analysis tab:** Set-up project parameters such as expected annual productivity increments and adoption rates, the spillover factor to neighboring countries, a benefit-cost ratio representative of farming systems in the focal area, and project economic parameters (total cost, duration, discounting rate, starting year of returns).
6. **Analysis tab: Productivity increment value** Calculate the value of the benefit that would result from a chosen % increase in crop and livestock productivity over the selected core and spillover areas (the increment can be adjusted);  
7. **Analysis tab: Marginal increase in value** The value of improved productivity is converted to range of plausible adoption rates and productivity increments at scale.
8. **Analysis tab: Avoided losses from reduction in CV** One way to translate reduced yield variability into production benefits is to calculate the economic losses avoided (in terms of value of production) for a percentage reduction in yield CV, measured with respect to the left-hand tail of the production distribution. A very approximate estimate is to assume that maize yields in farmers’ fields are distributed normally and calculate the difference in the probability densities of two normal yield density curves, one with the observed mean and yield CV and another with the same mean but a reduced yield CV. In practice, mean yields will increase through the use of CIS, but as explained above the focus here is on the avoided losses, which may be extremely important for household food security.
9. **Analysis tab: Investment indicators** For the range of productivity increments and adoption rates specified, with or without avoided losses from CIS use, three economic indicators are calculated for project performance: Net Present Value (NPV), Internal Rate of Return (IRR) and Benefit Cost Ratio (BCR ). The project duration, discount rate, starting year of returns and project cost are all adjustable.

All spatial variables are standardized to grids of 5 arcminute resolution (9.26 km or 85.75km2 at the equator).

### Datasets {.tabset .tabset-fade .tabset-pills}

```{r Datasets - Set base raster,echo=F}
# Set Base Raster
BaseRaster<-terra::rast("Data/cell5m_livestock_vop.tif")
```

**Core and spillover countries** 
*Choose core countries 1st (changing core resets spillover) and always keep 1 core country selected else the script may crash*
```{r Geographies - Load CGIAR countries (evaluated),echo=F,eval=T}
CGIAR_countries_sf<-sf::read_sf("Data/CGIAR_region/CGIAR_countries_simplified.shp",options = "ENCODING=UTF8")

CGIAR_countries_sf<-CGIAR_countries_sf[CGIAR_countries_sf$CG_REG %in% c("ESA","WCA") |
                                         CGIAR_countries_sf$ADMIN %in% c("Morocco","Western Sahara","Libya","Egypt","Algeria","Tunisia","Sudan"),]

sf::st_crs(CGIAR_countries_sf)<-4326
CGIAR_countries_sf$ADMIN[CGIAR_countries_sf$ADMIN=="United Republic of Tanzania"]<-"Tanzania"
CGIAR_countries_sf$ADMIN[CGIAR_countries_sf$ADMIN=="Ivory Coast"]<-"Cote d'Ivoire"
CGIAR_countries<-terra::vect(CGIAR_countries_sf)
```

:::: {style="display: flex;"}
::: {}
```{r Geographies - Choose core countries}
AICCRAcountries<-c("Kenya","Ethiopia","Ghana","Mali","Senegal","Zambia")

checkboxGroupInput(inputId="CountriesChoice", 
         label= "Core countries", 
         choices = sort(CGIAR_countries$ADMIN), 
         selected = "Kenya",
         inline = T)

```
:::
:::{}
```{r Geographies - Choose spillover countries}

AICCRAspillcountries<-c("Burundi","Rwanda","Tanzania","Uganda","Benin","Burkina Faso","Chad","Cote d'Ivoire",
                       "Cameroon","Guinea","Gambia","Guinea-Bissau","Mauritania","Niger","Nigeria","Togo",
                       "Botswana","Malawi","Mozambique","Zimbabwe")
renderUI({
  checkboxGroupInput(inputId="SpillCountriesChoice", 
           label= "Spillover countries", 
           choices = sort(CGIAR_countries$ADMIN[!CGIAR_countries$ADMIN %in% input$CountriesChoice]), 
           selected = NULL,
           inline = T)
})

ExtractBy.Core<-reactive({
  CGIAR_countries[CGIAR_countries$ADMIN %in% input$CountriesChoice]
})

ExtractBy.Spillover<-reactive({
  CGIAR_countries[CGIAR_countries$ADMIN %in% input$SpillCountriesChoice]
})

ExtractBy.All<-reactive({
  CGIAR_countries[CGIAR_countries$ADMIN %in% c(input$SpillCountriesChoice,input$CountriesChoice)]
})


```
:::
::::

**Farming systems** *you must select 1 or more*
```{r Farming Systems - Atlas, echo=F,eval=T}

if(!file.exists("Data/Farming_systems/FS1.tif")){
FarmSys<-terra::vect("Data/Farming_systems/fs_lev_2_update.shp")

FarmSys$LEV1_DESC<-data.table::tstrsplit(FarmSys$LEV1_DESC,"[.] ",keep=2)[[1]]
FarmSys$LEV1_DESC<-gsub(" farming system","",FarmSys$LEV1_DESC)
FarmSys$LEV2_DESC<-gsub(" farming system| subsystem","",FarmSys$LEV2_DESC)

FarmSys$Code1<-unlist(lapply(strsplit(FarmSys$LEV1_DESC," "),FUN=function(X){
  paste(
    c(
      stringr::str_to_title(substr(X[1],1,2)),
      stringr::str_to_title(substr(X[2:length(X)],1,1))
    ),collapse="")
}))

FarmSys$Code2<-unlist(lapply(strsplit(FarmSys$LEV2_DESC," |-"),FUN=function(X){
  paste(
    c(
      stringr::str_to_title(substr(X[1],1,2)),
      stringr::str_to_title(substr(X[2:length(X)],1,1))
    ),collapse="")
}))


FS1<-terra::aggregate(FarmSys[,c("LEV1_DESC")],"LEV1_DESC")
FS1<-terra::rasterize(FS1,BaseRaster,"LEV1_DESC",fun="near")

FS2<-terra::rasterize(FarmSys[,c("LEV2_DESC")],BaseRaster,"LEV2_DESC",fun=getmode)

FS_Metadata<-terra::values(FarmSys)

terra::writeRaster(FS1,filename="Data/Farming_systems/FS1.tif",overwrite=T)
terra::writeRaster(FS2,filename="Data/Farming_systems/FS2.tif",overwrite=T)
data.table::fwrite(FS_Metadata,file="Data/Farming_systems/FS_Metadata.csv")
}else{
 FS1<-terra::rast("Data/Farming_systems/FS1.tif")
 FS2<-terra::rast("Data/Farming_systems/FS2.tif")
 FS_Metadata<-data.table::fread("Data/Farming_systems/FS_Metadata.csv") 
}
```
    
```{r Farming Systems - GPLS, echo=F,eval=T}
# GLPS
GPLS_Legend<-data.table::fread("Data/GLPS/LPS_legend_RGB.csv")
GPLS_Legend$Code<-0:14
colnames(GPLS_Legend)[1]<-"ID"

LPS<-terra::crop(terra::resample(terra::rast("Data/GLPS/glps_gleam_61113_10km.tif"),BaseRaster,method="near"),CGIAR_countries)
LPS<-terra::mask(LPS,CGIAR_countries)
LPS<-LPS-1
LPS<-terra::categories(LPS,layer=1,value=GPLS_Legend,index=9)

```

:::: {style="display: flex;"}
::: {}
```{r Farming System - Choose classification, echo=F}
selectInput(inputId="FS_Choice", 
         label= "Classification", 
         choices = c("GLPS","Adaptation Atlas L1","Adaptation Atlas L2"), 
         selected = c("GLPS"),
         multiple = F,
         width="200px")

FS_Selected<-reactive({
    if(input$FS_Choice=="GLPS"){
     LPS
  }else{
    if(input$FS_Choice=="Adaptation Atlas L1"){
      FS1
    }else{
      FS2
      }
  }
})
```
:::
:::{}
```{r Farming System - Choose Systems, echo=F}
FS_Options<-reactive({
  FS_Options_Fun(FS_Selected=FS_Selected(),
                 ExtractBy.All=ExtractBy.All())
})

renderUI({
  checkboxGroupInput(inputId="FS_Systems", 
           label= NULL, 
           choices = FS_Options(), 
           selected = FS_Options()[!FS_Options() %in% c("Urban","Unsuitable")],
           inline = T)
})

```
:::
::::

**Crops (MapSPAM)**

:::: {style="display: flex;"}
::: {}
```{r Crops - Choose MapSPAM technology}
MS_options<-data.table::fread("Data/MapSPAM/MS Files.csv")

selectInput(inputId="MSTech", 
         label= "Technology", 
         choices = MS_options[,sort(unique(Tech))], 
         selected = c("all technologies"),
         multiple = F,
         width="200px")

MSTechCode<-reactive({MS_options[Tech==input$MSTech,unique(TechCode)]})
```
:::
:::{}
```{r Crops - Choose MapSPAM area type}
selectInput(inputId="MSAreaType", 
         label= "Area type", 
         choices = c("physical","harvested"), 
         selected = c("harvested"),
         multiple = F,
         width="200px")
```
:::
:::{}
```{r Extraction - Include totals,echo=F}
selectInput(inputId="IncTot", 
         label= "Extract totals?", 
         choices = c("Yes","No"), 
         selected = c("No"),
         multiple = F,
         width="150px")
```
:::
::::
```{r Crop - Choose crops}
renderUI({
checkboxGroupInput(inputId="CropChoice", 
         label= NULL, 
         choices = MS_options[TechCode==MSTechCode(),sort(unique(Crop))], 
         selected = c("maize","bean","cassava"),
         inline = T)
})
```

**Livestock**

```{r Livestock - Choose systems}
LSvop_options<-data.table::fread("Data/Herrero/LS Files.csv")

checkboxGroupInput(inputId="LSChoice", 
         label= NULL, 
         choices = LSvop_options[,sort(unique(System))], 
         selected = c("Bovine meat"),
         inline = T)

```

#### Countries
```{r Datasets - Crop base raster,echo=F}
BaseRaster<-terra::crop(BaseRaster,CGIAR_countries)
CellSize.km<-terra::cellSize(BaseRaster,mask=T, unit="km")
CellSize.ha<-terra::cellSize(BaseRaster,mask=T, unit="ha")

CountryRast<-terra::rasterize(CGIAR_countries,BaseRaster,"ADMIN")
CountryAreas<-data.table(
  terra::zonal(
    x=terra::cellSize(CountryRast,mask=T,unit="ha"),
    z=CountryRast,
    sum))

CGIAR_countries2<-reactive({
  CGCountriesFun(CGIAR_countries=CGIAR_countries,
                 CountriesChoice=input$CountriesChoice,
                 SpillCountriesChoice=input$SpillCountriesChoice,
                 CoreColour=input$BorderColCore,
                 SpillColour=input$BorderColSpill)
})

AddBorders<-reactive({
  function() {
    terra::plot(CGIAR_countries2(),add=T,border=CGIAR_countries2()$Colour,lwd=input$borderwidth,lty=CGIAR_countries2()$Linetype)
  }
})


```

```{r Datasets - plot CGIAR Countries, echo =F}
renderPlot({terra::plot(CGIAR_countries2(),
                        "Choice",
                        main="Selected countries",
                        border="black",
                        legend=input$LegPos,
                        type="classes",
                        pax=list(cex.axis=input$TextSize),
                        cex.main = input$TextSize*1.2,
                        axes = F,
                        frame.plot= F
                        )},
           height=Plot.Height, width=Plot.Width)
```


#### Farming systems
[GLPC Livestock Production Systems (LPS) map](https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi:10.7910/DVN/WPDSZE) by [Robinson et al. 2014](https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0096084)

The Adaptation L1 and L2 classifications are an adaption of [Dixon, John A., David P. Gibbon, and Aidan Gulliver. Farming systems and poverty: improving farmers' livelihoods in a changing world. Food & Agriculture Org., 2001](https://dataverse.harvard.edu/file.xhtml?persistentId=doi:10.7910/DVN/G4TBLF/7RIFT5&version=5.0).


```{r Datasets - Subset farming system, echo = F}
# This code relates to the farming system section, but is deliberately place here as when placed in the farming systems section it seemed to only activate when that tab was selected by the user. This prevented any analysis from proceeding.

Farming_System<-reactive({
  FSsub_Fun(FS=FS_Selected(),
            Choice = input$FS_Systems,
            Mask = ExtractBy.All())
})

```


```{r Datasets- Plot farming system, echo =F}
renderPlot({terra::plot(Farming_System(),
                        main=if(input$FS_Choice=="GLPS"){
                          "Livestock production systems"
                          }else{
                            if(input$FS_Choice=="Adaptation Atlas L1"){
                              "Farming systems level 1"
                              }else{
                                "Farming systems level 2"
                                }},
                        pax=list(cex.axis=input$TextSize),
                        plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
                        col=viridis(n=nrow(levels(Farming_System())[[1]]), 
                                    option =input$Palette,
                                    direction = if(input$Palette=="turbo"){1}else{-1}),
                        cex.main = input$TextSize*1.2,
                        axes = F,
                        legend = input$LegPos, 
                        frame.plot= F)
          terra::plot(CGIAR_countries2(),add=T,border=CGIAR_countries2()$Colour,lwd=input$borderwidth,lty=CGIAR_countries2()$Linetype)
  },height=Plot.Height, width=Plot.Width)
```

#### Crops (MapSPAM) {.tabset .tabset-fade .tabset-pills}
MapSPAM datasets are used for crop value of production (VoP), Yield, Total Production and Area and can be downloaded [here](https://dataverse.harvard.edu/dataset.xhtml?persistentId=doi:10.7910/DVN/FSSKBW) and methods reviewed [here](https://www.mapspam.info/methodology/).

**MapSPAM technology descriptions:**  

* **all technologies** = all technologies together, ie complete crop or crop group.  

* **irrigated** =	refers to the crop area equipped with either full or partial control irrigation. Normally the crop production on the irrigated fields uses a high level of inputs such as modern varieties and fertilizer as well as advanced management such as soil/water conservation measures.  

* **rainfed all** = rainfed portion of crop or crop group (= all technologies - irrigated).  

* **rainfed high** = rainfed-based, uses high-yield varieties and some animal traction and mechanization. It at least applies some fertilizer, chemical pest, disease or weed controls and most of the product is produced for the market.  

* **rainfed low** = rainfed crop production which uses traditional varieties and mainly manual labor without (or with little) application of nutrients or chemicals for pest and disease control. Production is mostly for their own consumption.  

* **rainfed subsistence** = rainfed, low-input/subsistence production was introduced to account for situations where cropland and suitable areas do not exist, but farmland is still present in some way.    
The definition of these production systems (management levels) more or less follows [FAO/IIASA’s GAEZ](http://www.iiasa.ac.at/Research/LUC/GAEZ/index.htm) project since SPAM uses its suitability surfaces.  

**MapSPAM area type descriptions:**  

* **Physical**  = Physical area is measured in a hectare and represents the actual area where a crop is grown, not counting how often production was harvested from it. Physical area is calculated for each production system and crop, and the sum of all physical areas of the four production systems constitute the total physical area for that crop. The sum of the physical areas of all crops in a pixel may not be larger than the pixel size.  

* **Harvested** = Harvested area is measured in a hectare, harvested area is at least as large as physical area, but sometimes more, since it also accounts for multiple harvests of a crop on the same plot. Like for physical area, the harvested area is calculated for each production system and the sum of all harvested areas of all production systems in a pixel amount to the total harvested area of the pixel. The sum of all the harvested areas of the crops in a pixel can be larger than the pixel size.  

Citation: *International Food Policy Research Institute, 2020, "Spatially-Disaggregated Crop Production Statistics Data in Africa South of the Sahara for 2017", https://doi.org/10.7910/DVN/FSSKBW, Harvard Dataverse, V3*  

##### Value of Production (VoP)
*SPAM’s cross entropy starts with prior knowledge of where crops may be grown and to which extent. It assumes that farmers, given a choice of different crops, will grow those which generate more revenue, this is where crop prices come in. SPAM uses a different price for every crop, but the same price for all countries: 2004-2006 average international price, as used by FAO to compute Value of Production.*  
Download VoP [here](https://dataverse.harvard.edu/file.xhtml?fileId=4271679&version=3.0).

```{r Datasets - Load MapSPAM VoP,echo=F}
MSvop<-reactive({
   if(!is.null(input$CropChoice)){
    MSfun(VAR="VOP",
          TECH=MSTechCode(),
          CROPS=input$CropChoice,
          BaseRaster=BaseRaster,
          MASK=Farming_System(),
          MS_options=MS_options,
          Name="_vop",
          IncTot=input$IncTot)
   }else{
     NA
   }
})
```

**MapSPAM Crop Value of Production USD/pixel**
```{r Datasets - Plot MSvop, echo =F,error=F,warning=F}
renderPlot({terra::plot(if(input$log_plots=="Yes"){log(MSvop())}else{MSvop()},
                        fun=AddBorders(),
                        pax=list(cex.axis=input$TextSize),
                        plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
                        col=viridis(n=20,
                                    option =input$Palette,
                                    direction = if(input$Palette=="turbo"){1}else{-1}),
                        cex.main = input$TextSize*1.2,
                        legend = input$LegPos,
                        axes = F,
                        frame.plot= F)
  },height=Plot.Height, width=Plot.Width)
```


##### Area
**Physical area** *is measured in a hectare and represents the actual area where a crop is grown, not counting how often production was harvested from it. Physical area is calculated for each production system and crop, and the sum of all physical areas of the four production systems constitute the total physical area for that crop. The sum of the physical areas of all crops in a pixel may not be larger than the pixel size.*  
Download crop physical area [here](https://dataverse.harvard.edu/file.xhtml?fileId=4271676&version=3.0).

**Harvested area** *is also measured in a hectare, and  is at least as large as physical area, but sometimes more, since it also accounts for multiple harvests of a crop on the same plot. Like for physical area, the harvested area is calculated for each production system and the sum of all harvested areas of all production systems in a pixel amount to the total harvested area of the pixel. The sum of all the harvested areas of the crops in a pixel can be larger than the pixel size.*  
Download crop harvested area [here](https://dataverse.harvard.edu/file.xhtml?fileId=4271688&version=3.0).

```{r Datasets - MapSPAM physical area, echo=F}
MShparea<-reactive({
   if(!is.null(input$CropChoice)){
    MSfun(VAR="PhysArea",
          TECH=MSTechCode(),
          CROPS=input$CropChoice,
          BaseRaster=BaseRaster,
          MASK=Farming_System(),
          MS_options=MS_options,
          Name="_area",
          IncTot=input$IncTot)
   }else{
     NA
   }
})
```

```{r Datasets - MapSPAM harvested area, echo=F}
MSharea<-reactive({
   if(!is.null(input$CropChoice)){
    MSfun(VAR="HarvArea",
          TECH=MSTechCode(),
          CROPS=input$CropChoice,
          BaseRaster=BaseRaster,
          MASK=Farming_System(),
          MS_options=MS_options,
          Name="_area",
          IncTot=input$IncTot)
   }else{
     NA
   }
})
```

```{r Set Area Type to be used in analysis,echo=F}
MSarea<-reactive({
  if(!is.null(input$CropChoice)){
    if(input$MSAreaType=="Physical"){
      MShparea()
      }else{
        MSharea()
        }
     }else{
       NA
     }
  })
```

**MapSPAM crop physical area - ha/pixel**
```{r Datasets - Plot MShparea, echo = F,error=F,warning=F}
renderPlot({   
  if(!is.null(input$CropChoice)){
    terra::plot(if(input$log_plots=="Yes"){log(MShparea())}else{MShparea()},
                fun=AddBorders(),
                pax=list(cex.axis=input$TextSize),
                plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
                col=viridis(n=20,
                            option =input$Palette,
                            direction = if(input$Palette=="turbo"){1}else{-1}),
                cex.main = input$TextSize*1.2,
                legend = input$LegPos,
                axes = F,
                frame.plot= F)
    terra::plot(CGIAR_countries,add=T,border=input$BorderCol)
  }
  },height=Plot.Height, width=Plot.Width)
```

**MapSPAM crop harvested area - ha/pixel**
```{r Datasets - Plot MSharea, echo = F,error=F,warning=F}
renderPlot({
     if(!is.null(input$CropChoice)){
       terra::plot(if(input$log_plots=="Yes"){log(MSharea())}else{MSharea()},
                   pax=list(cex.axis=input$TextSize),
                   plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
                   col=viridis(n=20,
                               option =input$Palette,
                               direction = if(input$Palette=="turbo"){1}else{-1}),
                   cex.main = input$TextSize*1.2,
                   legend = input$LegPos,
                   axes = F,
                   frame.plot= F)
       terra::plot(CGIAR_countries,add=T,border=input$BorderCol)
     }
  },height=Plot.Height, width=Plot.Width)
```

##### Production
**Production** *, for each production system and crop, is calculated by multiplying area harvested with yield. It is measured in metric tons. The total production of a crop includes the production of all production systems of that crop.*  
Download crop production volume [here](https://dataverse.harvard.edu/file.xhtml?fileId=4271677&version=3.0).

```{r Datasets - MapSPAM crop production, echo=F}
MSprod<-reactive({
   if(!is.null(input$CropChoice)){
    MSfun(VAR="Production",
          TECH=MSTechCode(),
          CROPS=input$CropChoice,
          BaseRaster=BaseRaster,
          MASK=Farming_System(),
          MS_options=MS_options,
          Name="_prod",
          IncTot=input$IncTot)
   }else{
     NA
   }
})
```

**MapSPAM Production - ton/pixel**
```{r Datasets - Plot MSprod, echo = F,error=F,warning=F}
renderPlot({     
  if(!is.null(input$CropChoice)){
    terra::plot(if(input$log_plots=="Yes"){log(MSprod())}else{MSprod()},   
                fun=AddBorders(),
                pax=list(cex.axis=input$TextSize),
                plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
                col=viridis(n=20,
                            option =input$Palette,
                            direction = if(input$Palette=="turbo"){1}else{-1}),
                cex.main = input$TextSize*1.2,
                legend = input$LegPos,
                axes = F,
                frame.plot= F)
    terra::plot(CGIAR_countries,add=T,border=input$BorderCol)
  }
  },height=Plot.Height, width=Plot.Width)
```

*Yield is a measure of productivity, the amount of production per harvested area, and is measured in kilogram/hectare. The total yield of a crop, when considering all production systems, is not the sum of the individual yields, but the weighted average of the 4 yields. Note that we do not directly extract yield from MapSPAM rasters in this analysis, rather we calculate by dividing production by harvested area.*  

#### Livestock {.tabset .tabset-fade .tabset-pills}
These datasets come from [Herrero et al. 2013](https://www.pnas.org/doi/abs/10.1073/pnas.1308149110) in particular see the [supporting information](https://www.pnas.org/doi/suppl/10.1073/pnas.1308149110/suppl_file/sapp.pdf) for a detailed explanation of their methods.

Livestock VoP (as for crops) was calculated as production (t) times price ($/t). In the PNAS dataset, one international (global) price was used for each commodity for comparability, and these were 2005 dollars (Phil Thorton *pers comms*).

##### Value of production (VoP) 
```{r Datasets - Load LSvop,echo=F}
# *CellSize.km to convert from USD/km2/year to USD/pixel/year

LSvop1<-reactive({
    if(!is.null(input$LSChoice)){
  terra::mask(terra::crop(
     terra::rast(paste0("Data/Herrero/Resampled/",LSvop_options[System %in% input$LSChoice & Variable=="VOP",Filename]))*CellSize.km
  ,Farming_System()),Farming_System())
  }else{
    NA
  }
})

```

```{r Datasets - LS rename and add totals, echo=F}
# Rename layers
LSvop<-reactive({
    if(!is.null(input$LSChoice)){
  LSfun(Data=LSvop1(),Choice=input$LSChoice,Extension="_vop",TotalName="LS",IncTot=input$IncTot)
  }else{
    NA
  }
})

```

**Value of livestock production  USD/pixel**
```{r Datasets - Plot LSvop, echo =F,error=F}
renderPlot({    
  if(!is.null(input$LSChoice)){
    terra::plot(if(input$log_plots=="Yes"){log(LSvop())}else{LSvop()},
                fun=AddBorders(),
                pax=list(cex.axis=input$TextSize),
                plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
                col=viridis(n=20,
                            option =input$Palette,
                            direction = if(input$Palette=="turbo"){1}else{-1}),
                cex.main = input$TextSize*1.2,
                axes = F,
                frame.plot= F)
  }
  },height=Plot.Height, width=Plot.Width)

```

##### Yield & production
*Yield units are converted from kg/km2/year to t/km2/year*
```{r Datasets - Load LSyield,echo=F}
# Divide by 1000 to convert kg to t
LSyield<-reactive({
    if(!is.null(input$LSChoice)){
    terra::mask(
      terra::crop(
        terra::rast(paste0("Data/Herrero/Resampled/",LSvop_options[System %in% input$LSChoice & Variable=="MeatYield",Filename]))/1000,
        Farming_System()),
      Farming_System())
    }else{
      NA
      }
})

# *CellSize.km converts yield t/km2/year to production per pixel t/pixel/year
LSprod2<-reactive({
    if(!is.null(input$LSChoice)){
    terra::mask(terra::crop(
      terra::rast(paste0("Data/Herrero/Resampled/",LSvop_options[System %in% input$LSChoice & Variable=="MeatYield",Filename]))/1000*CellSize.km
      ,Farming_System()),Farming_System())
  }else{
    NA
  }
})

# Rename layers
LSprod<-reactive({
    if(!is.null(input$LSChoice)){
    LSfun(Data=LSprod2(),Choice=input$LSChoice,Extension="_prod",TotalName="LS",IncTot=input$IncTot)
  }else{
    NA
  }
})

```

**Livestock production t/pixel**
```{r Datasets - Plot LSprod, echo =F,error=F,warning=F}
renderPlot({    
  if(!is.null(input$LSChoice)){
    terra::plot(if(input$log_plots=="Yes"){log(LSprod())}else{LSprod()},
                fun=AddBorders(),
                pax=list(cex.axis=input$TextSize),
                plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
                col=viridis(n=20,
                            option =input$Palette,
                            direction = if(input$Palette=="turbo"){1}else{-1}),
                cex.main = input$TextSize*1.2,
                legend = input$LegPos,
                axes = F,
                frame.plot= F)
  }
  },height=Plot.Height, width=Plot.Width)
```

**Livestock yield t/ha**
```{r Datasets - Plot LSyield, echo =F,error=F,warning=F}
renderPlot({   
  if(!is.null(input$LSChoice)){
    terra::plot(if(input$log_plots=="Yes"){log(LSyield())}else{LSyield()},
                fun=AddBorders(),
                pax=list(cex.axis=input$TextSize),
                plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
                col=viridis(n=20,
                            option =input$Palette,
                            direction = if(input$Palette=="turbo"){1}else{-1}),
                cex.main = input$TextSize*1.2,
                axes = F,
                frame.plot= F)
  }
  },height=Plot.Height, width=Plot.Width)
```

##### LS Area
*Note that we do not have a layer for this data so cellsize is currently substituted.*
```{r Datasets - Load LSarea,echo=F}
LSarea1<-reactive({
      if(!is.null(input$LSChoice)){
      LSareaFun(Data=LSprod())
    }else{
      NA
    }
})

# Rename layers
LSarea<-reactive({
      if(!is.null(input$LSChoice)){
      LSfun(Data=LSarea1(),Choice=input$LSChoice,Extension="_area",TotalName="LS",IncTot=input$IncTot)
    }else{
      NA
    }
})

```

**Livestock area (pixel size, ha)**
```{r Datasets - Plot LSarea, echo =F,error=F,warning=F}
renderPlot({    
  if(!is.null(input$LSChoice)){
    terra::plot(LSarea(),
                fun=AddBorders(),
                pax=list(cex.axis=input$TextSize),
                plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
                col=viridis(n=20,
                            option =input$Palette,
                            direction = if(input$Palette=="turbo"){1}else{-1}),
                cex.main = input$TextSize*1.2,
                lengend = input$LegPos,
                axes = F,
                frame.plot= F)
  }
  },height=Plot.Height, width=Plot.Width)
```

#### FAOSTAT{.tabset .tabset-fade .tabset-pills}
FAO data are used to estimate the national level variation in crop production over time. They are downloaded using the [FAOSTAT::get_faostat_bulk](https://search.r-project.org/CRAN/refmans/FAOSTAT/html/download_faostat_bulk.html) function. Data can also be accessed from the  [FAOSTAT website](https://www.fao.org/faostat/en/#data/QCL) and directly downloaded [here](https://fenixservices.fao.org/faostat/static/bulkdownloads/Production_Crops_Livestock_E_All_Data_(Normalized).zip).  

##### Prepare data
```{r Datasets - Load FAOSTAT, echo=T}
FAODir<-"Data/FAO"
FAOFile<-paste0(FAODir,"/FAO_prod.RData")

if(!file.exists(FAOFile)){
if(!dir.exists(FAODir)){
  dir.create(FAODir)
}
  
fao_metadata<-FAOSTAT::FAOsearch()
#FAOSTAT::FAOsearch(dataset="crop",full=FALSE)
FAO_prod<-data.table(FAOSTAT::get_faostat_bulk(code="QCL",data_folder=FAODir))

UpdateFAOCountries<-data.table(
  FAO=c("Bolivia (Plurinational State of)","Iran (Islamic Republic of)","Syrian Arab Republic","Congo","Viet Nam","Lao People's Democratic Republic","Côte d'Ivoire","Timor-Leste","Brunei Darussalam","Eswatini","Venezuela (Bolivarian Republic of)","Bahamas","United Republic of Tanzania"),
  CGIAR=c("Bolivia","Iran","Syria","Republic of the Congo","Vietnam","Laos","Cote d'Ivoire","East Timor","Brunei","eSwatini","Venezuela","The Bahamas","Tanzania")
)

# Match then update FAO names with CGIAR names
N<-match(FAO_prod[,area],UpdateFAOCountries[,FAO])

FAO_prod[which(!is.na(N)),area:=UpdateFAOCountries[N[!is.na(N)],CGIAR]]
FAO_prod<-FAO_prod[area %in% CGIAR_countries$ADMIN]

save(FAO_prod,file=FAOFile)

# Remove downloaded zip file
unlink("Data/FAO/Production_Crops_Livestock_E_All_Data_(Normalized).zip")

}else{
  FAO_prod<-miceadds::load.Rdata2(FAOFile)
}

FAO_prod<-FAO_prod[element %in% c("yield","milk_animals","yield_carcass_weight") & !is.na(value) & year %in% 2001:2020]

# Convert hg/ha to t/ha
FAO_prod[,value:=as.numeric(value)
         ][unit=="hg/ha",value:=value*0.0001
           ][unit=="hg/ha",unit:="t/ha"]
```

**Calculate coefficient of variation**
```{r Datasets - FAOSTAT calculate CV,echo=T}
FAO_CV<-FAO_prod[,list(Mean=mean(value),
                       SD=sd(value),
                       CV=100*(sd(value)/mean(value)),
                       N.Years=.N),by=list(area,item,element,unit)]
```

```{r Datasets -  Map FAO names to MapSPAM,echo=T}
#Map FAO names to MapSPAM
  
MSCrops<-MS_options[,unique(Crop)]
FAOCrops<-FAO_CV[,tolower(unique(item))]

CropMatch<-MSCrops[MSCrops %in% FAOCrops]
CropNoMatch<-MSCrops[!MSCrops %in% FAOCrops]

CropMappings<-data.table(MapSPAM=MSCrops,FAO=as.character(NA))
CropMappings[MapSPAM %in% FAOCrops,FAO:=MapSPAM]

CropMappings[MapSPAM=="arabica coffee",FAO:="coffee, green"]
CropMappings[MapSPAM=="banana",FAO:="bananas"]
CropMappings[MapSPAM=="bean",FAO:="beans, dry"]
CropMappings[MapSPAM=="chickpea",FAO:="chick peas"]
CropMappings[MapSPAM=="coconut",FAO:="coconuts"]
CropMappings[MapSPAM=="cocoa",FAO:="cocoa, beans"]
CropMappings[MapSPAM=="cotton",FAO:="seed cotton"]
CropMappings[MapSPAM=="cowpea",FAO:="cow peas, dry" ]
CropMappings[MapSPAM=="groundnut",FAO:="groundnuts, with shell"]
CropMappings[MapSPAM=="lentil",FAO:="lentils"]
CropMappings[MapSPAM=="other cereals",FAO:="cereals nes"]
CropMappings[MapSPAM=="other fibre crops",FAO:="fibre crops nes"]
CropMappings[MapSPAM=="oilpalm",FAO:="oil palm fruit"]
CropMappings[MapSPAM=="other oil crops",FAO:="oilseeds nes"]
CropMappings[MapSPAM=="other pulses",FAO:="pulses nes"]
CropMappings[MapSPAM=="other roots",FAO:="roots and tubers nes"]
CropMappings[MapSPAM=="pigeonpea",FAO:="pigeons peas"]
CropMappings[MapSPAM=="plantain",FAO:="plantains and others"]
CropMappings[MapSPAM=="pearl millet",FAO:="millet"]
CropMappings[MapSPAM=="potato",FAO:="potatoes"]
CropMappings[MapSPAM=="robusta coffee",FAO:=NA]
CropMappings[MapSPAM=="rest of crops",FAO:=NA]
CropMappings[MapSPAM=="rice",FAO:="rice, paddy"]
CropMappings[MapSPAM=="sesameseed",FAO:="sesame seed"]
CropMappings[MapSPAM=="small millet",FAO:=NA]
CropMappings[MapSPAM=="soybean",FAO:="soybeans"]
CropMappings[MapSPAM=="sugarbeet",FAO:="sugar beet"]
CropMappings[MapSPAM=="sugarcane",FAO:="sugar cane"]
CropMappings[MapSPAM=="sunflower",FAO:="sunflower seed"]
CropMappings[MapSPAM=="sweet potato",FAO:="sweet potatoes"]
CropMappings[MapSPAM=="temperate fruit",FAO:=NA]
CropMappings[MapSPAM=="tropical fruit",FAO:="fruit, tropical fresh nes"]
CropMappings[MapSPAM=="vegetables",FAO:="vegetables primary"]
CropMappings[MapSPAM=="tobacco",FAO:="tobacco, unmanufactured"]

FAO_CV[,SpamName:=CropMappings[match(tolower(FAO_CV$item),CropMappings$FAO),MapSPAM]]
FAO_CV<-FAO_CV[!is.na(SpamName)]

FAO_prod[,SpamName:=CropMappings[match(tolower(FAO_prod$item),CropMappings$FAO),MapSPAM]]
FAO_prod<-FAO_prod[!is.na(SpamName)]

```

##### Raw data
To interpret these data please see the meta-data section under `Crops and livestock products` in this [FAOSTAT website](https://www.fao.org/faostat/en/#data/QCL) and this [pdf](https://fenixservices.fao.org/faostat/static/documents/Default_coding_and_flags.pdf). The `SpamName` field converts the FAO crop name in the `item` column to the corresponding SPAM name.
```{r Datasets - FAOSTAT DT Raw, echo=F}
  renderDT({
    datatable(dplyr::mutate_if(FAO_prod,is.numeric,~round(.,3)),
                caption="",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  })
```

##### Coefficent of variation (CV)
For a national time series of crop yields CV is calculated as `100*(sd(crop_yield)/mean(crop_yield))`.
```{r Datasets - FAOSTAT DT, echo=F}
  renderDT({
    datatable(dplyr::mutate_if(FAO_CV,is.numeric,~round(.,3)),
                caption="",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  })
```

##### Plot
```{r Datasets - Prepare FAO plot data,echo=F,eval=T}
FAOCountries<-reactive({
  FAOPlot(Map=CGIAR_countries2(),FAO_CV=FAO_CV,CropChoice=input$CropChoice)
})
```

Countries with no fill colour indicate either a crop is not grown in this country or there is no yield information for the crop in FAOstat.

**Coefficient of variation**
```{r Datasets - plot FAO data CV, echo =F}
renderPlot({terra::plot(FAOCountries(),
                        paste0(input$CropChoice,"_CV"),
                        border=FAOCountries()$Colour,
                        lty=FAOCountries()$Linetype,
                        legend=input$LegPos,
                        type="continuous",
                        pax=list(cex.axis=input$TextSize),
                        cex.main = input$TextSize*1.2,
                        axes = F,
                        range=c(0,ceiling(max(values(FAOCountries()[,paste0(input$CropChoice,"_CV")]),na.rm=T))),
                        col=viridis(n=20,
                        option =input$Palette,
                        direction = if(input$Palette=="turbo"){1}else{-1})
                        )
                        },
           height=Plot.Height, width=Plot.Width)
```

**Mean yields (t/ha)**
```{r Datasets - plot FAO data yields, echo =F}
renderPlot({terra::plot(FAOCountries(),
                        paste0(input$CropChoice,"_Mean"),
                        border=FAOCountries()$Colour,
                        lty=FAOCountries()$Linetype,
                        legend=input$LegPos,
                        type="continuous",
                        pax=list(cex.axis=input$TextSize),
                        cex.main = input$TextSize*1.2,
                        axes = F,
                        range=c(0,ceiling(max(values(FAOCountries()[,paste0(input$CropChoice,"_Mean")]),na.rm=T))),
                        col=viridis(n=20,
                        option =input$Palette,
                        direction = if(input$Palette=="turbo"){1}else{-1})
                        )},
           height=Plot.Height, width=Plot.Width)
```

**Download data used the CV and mean yield plots above**
```{r Datasets - FAOSTAT Plot DT, echo=F}
  renderDT({
    datatable(dplyr::mutate_if(as.data.table(FAOCountries())[!is.na(Choice),!c("CG_REG","Colour","Linetype")],is.numeric,~round(.,3)),
                caption="",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  })
```

#### Human population
*Not currently used in the analysis, but may be integrated in future*
```{r Datasets - Load Hpop, echo = F}
# Load and resample raster
Hpop2<-terra::resample(terra::rast(unzip("Data/Exposure/cell5m_ruralpop_2020_v3.zip")),BaseRaster,method="bilinear")
# Force raster into memory 
if(terra::sources(Hpop2)!=""){
  Hpop2<-terra::rast(raster::readAll(raster::raster(Hpop2)))
}

# Remove unzipped file
unlink("cell5m_ruralpop_2020_v3.tif")

# Name raster
names(Hpop2)<-"Hpop"

Hpop<-reactive({
  terra::mask(terra::crop(Hpop2,Farming_System()),Farming_System())
})

```

**ln(people)/pixel**
```{r Datasets - Plot Hpop, echo = F}
renderPlot({terra::plot(if(input$log_plots=="Yes"){log(Hpop())}else{Hpop()},
                        fun=AddBorders(),
                        pax=list(cex.axis=input$TextSize),
                        plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
                        col=viridis(n=20,
                                    option =input$Palette,
                                    direction = if(input$Palette=="turbo"){1}else{-1}),
                        cex.main = input$TextSize*1.2,
                        legend = input$LegPos,
                        axes = F,
                        frame.plot= F)
  },height=Plot.Height, width=Plot.Width)
```

#### Climate hazards
*Not currently used in the analysis, but may be integrated in future*
**CHIRPS rainfall coefficient of variation**
```{r Datasets - Load climate hazards, echo = F}
RainCV2<-terra::resample(terra::rast("Data/Hazards/chirps_cv.tif"),BaseRaster,method="near")
names(RainCV2)<-"RainCV"

RainCV<-reactive({
  terra::mask(terra::crop(RainCV2,Farming_System()),Farming_System())
})

```

```{r Datasets - Plot RainCV, echo = F}
renderPlot({terra::plot(if(input$log_plots=="Yes"){log(RainCV())}else{RainCV()},
                        fun=AddBorders(),
                        pax=list(cex.axis=input$TextSize),
                        plg=list(x=input$LegPos,cex = input$TextSize,ncol=input$LegCols),
                        col=viridis(n=20,
                                    option =input$Palette,
                                    direction = if(input$Palette=="turbo"){1}else{-1}),
                        cex.main = input$TextSize*1.2,
                        legend = input$LegPos,
                        axes = F,
                        frame.plot= F)
  },height=Plot.Height, width=Plot.Width)
```
#### Combine selections
Here the data selections are combined into a raster stack.
```{r Datasets - Stack datasets,echo=T}
names(CellSize.ha)<-"Area.ha"


Stacked<-reactive({
    if(!is.null(input$LSChoice)){
       if(!is.null(input$CropChoice)){
         c(Farming_System(),
          LSvop(),
          LSarea(),
          LSprod(),
          MSvop(),
          MSarea(),
          MSprod(),
          Hpop(),
          RainCV()
        )
         }else{
           c(Farming_System(),
            LSvop(),
            LSarea(),
            LSprod(),
            Hpop(),
            RainCV()
          )
         }
    }else{
      c(Farming_System(),
        MSvop(),
        MSarea(),
        MSprod(),
        Hpop(),
        RainCV()
        )
    }
})

# Columns to sum
SumCols<-reactive({
  c(names(Stacked())[!names(Stacked()) %in% c("Farming_System","CellSize.ha","RainCV")],"CellSize.ha")
})

# Columns to analyse
prod_cols<-reactive({
  if(!is.null(input$LSChoice)){
    if(!is.null(input$CropChoice)){
      c(names(MSprod()),names(LSprod()))
    }else{
      names(LSprod())
    }
    }else{
      names(MSprod())
      }
  })



area_cols<-reactive({
  if(!is.null(input$LSChoice)){
    if(!is.null(input$CropChoice)){
      c(names(MSarea()),names(LSarea()))
    }else{
      names(LSarea())
    }
  }else{
    names(MSarea())
  }
  })

vop_cols<-reactive({
  if(!is.null(input$LSChoice)){
    if(!is.null(input$CropChoice)){
      c(names(MSvop()),names(LSvop()))
    }else{
      names(LSvop())
    }
  }else{
    names(MSvop())
  }
  })
```
### Analysis {.tabset .tabset-fade .tabset-pills}

<font size="4"> **Technology performance parameters**</font>

:::: {style="display: flex;"}
::: {}

**Productivity increments (%)**  
*1-3 values can be entered.*  

:::: {style="display: flex;"}
::: {}
```{r Parameter - Productivity Increment 1,echo=F}
  numericInput(inputId="PI_1", 
              label="Value 1",
              value = 5,
              min=0,              
              max=100,
              step = 1,
              width="90px")
```
:::
:::{}
```{r Parameter - Productivity Increment 2,echo=F}
  numericInput(inputId="PI_2", 
              label="Value 2",
              value = 10,
              min=0,              
              max=100,
              step = 1,
              width="90px")
```
:::
:::{}
```{r Parameter - Productivity Increment 3,echo=F}
  numericInput(inputId="PI_3", 
              label="Value 3",
              value = NULL,
              min=0,              
              max=100,
              step = 1,
              width="90px")
```
:::
::::

:::
:::{}

**Annual adoption rates in core areas(%)**  
*1-3 values can be entered.* 

:::: {style="display: flex;"}
::: {}
```{r Parameter - Core Adoption Rate 1,echo=F}
  numericInput(inputId="CAAR_1", 
              label="Value 1",
              value = 1,
              min=0,              
              max=100,
              step = 1,
              width="100px")
```
:::
:::{}
```{r Parameter - Core Adoption Rate 2,echo=F}
  numericInput(inputId="CAAR_2", 
              label="Value 2",
              value = 2,
              min=0,              
              max=100,
              step = 1,
              width="100px")
```
:::
:::{}
```{r Parameter - Core Adoption Rate 3,echo=F}
  numericInput(inputId="CAAR_3", 
              label="Value 3",
              value = 3,
              min=0,              
              max=100,
              step = 1,
              width="100px")
```
:::
::::

:::
:::{}

*The % of adoption in core countries*  
*that spills to spillover countries* 
```{r Parameter - Spillover Factor,echo=F}
  numericInput(inputId="SpillFactor", 
              label="Spillover Factor",
              value = 1,
              min=0,              
              max=100,
              step = 1,
              width="230px")
```

:::
:::{}


**Costs***  
*Annual total costs (USD/ha) or benefit-cost ratio (BCR)* 

:::: {style="display: flex;"}
::: {}
```{r Parameter - Costs 1,echo=F}
  numericInput(inputId="CostAdopt", 
              label="Cost adopters",
              value =  221.60 ,
              min=0,              
              max=10000,
              step = 10,
              width="110px")
```
:::
:::{}
```{r Parameter - Costs 2,echo=F}
  numericInput(inputId="CostNonAdopt", 
              label="Cost non-adopters",
              value = 170.46,
              min=0,              
              max=10000,
              step = 10,
              width="130px")
```
:::
:::{}
```{r Parameter - Non BCR,echo=F}
  numericInput(inputId="Non_BCR", 
              label="BCR (Ratio)",
              value = NULL,
              min=0,              
              max=10,
              step = 0.01,
              width="110px")
```
:::
::::


:::
:::{}

*To estimate the value of CIS this value is*  
*subtracted from country x crop CV values*
```{r Parameter - CV reduction amount,echo=F}
  numericInput(inputId="CV_Change", 
              label="CV reduction",
              value = 5,
              min=0,              
              max=100,
              step = 1,
              width="300px")
```
:::
::::

***IMPORTANT** *Do not use costs with livestock, use BCR. Defining costs does not work for livestock systems. This because cost are defined on per ha basis and the livestock areas used are for entire farming systems giving very low yields per unit area. We must use the entire farming system area because the spatial footprint of livestock production is not available for livestock (as it is from MapSPAM for crops). When using livestock, you will need to leave the costs blank and use the BCR option*

```{r Parameters - Combine PIs & AARS,echo=F}
Pr.Inc<-reactive({
  c(input$PI_1,input$PI_2,input$PI_3)[!is.na(c(input$PI_1,input$PI_2,input$PI_3))]/100
})

Ad.Rates.Core<-reactive({
  c(input$CAAR_1,input$CAAR_2,input$CAAR_3)[!is.na(c(input$CAAR_1,input$CAAR_2,input$CAAR_3))]/100
})

Ad.Rates.Spillover<-reactive({
  Ad.Rates.Core()*(input$SpillFactor/100)
})
```

<font size="4"> **Project economic parameters**</font>

:::: {style="display: flex;"}
::: {}

*The project duration in years*
```{r Parameter - Timeframe,echo=F}
  numericInput(inputId="Years", 
              label="Duration (years)",
              value = 10,
              min=1, 
              max=50,
              step = 1,
              width="250px")
```
:::
:::{}

*Discount rate used for NPV calculations*
```{r Parameter - Discount Rate,echo=F}
  numericInput(inputId="DiscountRate1", 
              label="Discount rate (%)",
              value = 5,
              min=0,              
              max=100,
              step = 1,
              width="250px")

DiscountRate<-reactive({input$DiscountRate1/100})
```
:::
:::{}

*The year that returns begin after investment?* 
```{r Parameter - StartPeriod,echo=F}
  selectInput(inputId="StartYear1", 
              label="Return start year",
              choices = c(0,1,2),
              selected=1, 
              multiple = F,
              width="300px")

StartYear<-reactive({as.numeric(input$StartYear1)})
```
:::
:::{}

*The cost of the project (million USD)*
```{r Parameter - Project Cost,echo=F}
  numericInput(inputId="ProjectCost1", 
              label="Project cost",
              value = 60,
              min=0,              
              max=10000,
              step = 5,
              width="250px")

ProjectCost<-reactive({input$ProjectCost1*10^6})
```
:::
::::

<font size="4"> **Adjust display of units in output tables**</font>

:::: {style="display: flex;"}
::: {}
```{r Parameter - Value units,echo=F}
selectInput(inputId="USD_Units", 
            label="Divide USD by:",
            choices = c(1,10,100,1000,10000,100000,1000000), 
            selected = 1,
            multiple = F,
            width="150px")

```
:::
:::{}
```{r Parameter - Area units,echo=F}
selectInput(inputId="Area_Name", 
            label="Area unit:",
            choices = c("ha","km2","10km2","100km2"), 
            selected = 1,
            multiple = F,
            width="150px")

Area_Unit<-reactive({
  if(input$Area_Name=="ha"){
    1
  }else{
  if(input$Area_Name=="km2"){
    100
  }else{
  if(input$Area_Name=="10km2"){
   1000
  }else{
  if(input$Area_Name=="100km2"){
  10000
}}}}
})

```
:::
:::{}
```{r Parameter - Population units,echo=F}
selectInput(inputId="Pop_Unit", 
            label="Divide population by:",
            choices = c(1,10,100,1000,10000,100000,1000000), 
            selected = 1,
            multiple = F,
            width="170px")

```
:::
:::{}
```{r Parameter - Production units,echo=F}
selectInput(inputId="Prod_Unit", 
            label="Divide production (t) by:",
            choices = c(1,10,100,1000,10000,100000,1000000), 
            selected = 1,
            multiple = F,
            width="170px")

```
:::
::::

#### Extracted data{.tabset .tabset-fade .tabset-pills}
##### Core countries{.tabset .tabset-fade .tabset-pills}
```{r Extraction - Core countries,echo=F}
Stats.Core<-reactive({
  StackExtractor1(Data=Stacked(), 
                  ExtractBy = ExtractBy.Core(), 
                  SumCols=SumCols(),
                  prod_cols=prod_cols(),
                  area_cols=area_cols(),
                  vop_cols=vop_cols())
})

CoreAreas<-reactive({
  AreaCalc(Stats=Stats.Core(),CountryAreas=CountryAreas)
})

```

###### Extraction
Each row in the extracted data tables represents a farming system within a country. Explanation of table headings:  
**`Area.ha`** = area (ha)  
**`Hpop`** = human population  
**`RainCV.ln`** = natural log of mean rainfall CV  
suffix **`vop`** = commodity value of production (international USD)  
suffix **`area`** = commodity area of production (km2)  
suffix **`yield`** = commodity yield (ton/ha)  
suffix **`price`** = 2005 commodity price (international USD/ton)  
```{r Extraction - Core countries DT, echo=F}

Stats.Core.Disp<-reactive({
  FormatExtraction(Data=data.table::copy(Stats.Core()),
                 vop_cols=vop_cols(),
                 area_cols=area_cols(),
                 prod_cols=prod_cols(),
                 USD_Units=as.numeric(input$USD_Units),
                 Area_Unit=as.numeric(Area_Unit()),
                 Prod_Unit=as.numeric(input$Prod_Unit),
                 Pop_Unit=as.numeric(input$Pop_Unit),
                 Area_Name=input$Area_Name)
})

  renderDT({
    datatable(dplyr::mutate_if(Stats.Core.Disp(),is.numeric,~round(.,3)),
                caption="",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  })
```

###### Farming System Areas
```{r Extraction - Core countries FS Area DT, echo=F}
  renderDT({
    datatable(CoreAreas(),
                caption="",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  })
```

##### Spillover countries{.tabset .tabset-fade .tabset-pills}
```{r Extraction - Spillover countries,echo=F}
Stats.Spillover<-reactive({
  StackExtractor1(Data=Stacked(), 
                  ExtractBy = ExtractBy.Spillover(), 
                  SumCols=SumCols(),
                  prod_cols=prod_cols(),
                  area_cols=area_cols(),
                  vop_cols=vop_cols())
})

CoreAreasSpill<-reactive({
  AreaCalc(Stats=Stats.Spillover(),CountryAreas=CountryAreas)
})
```
###### Extraction
Each row in the extracted data tables represents a farming system within a country. Explanation of table headings:  
**`Area.ha`** = area (ha)  
**`Hpop`** = human population  
**`RainCV.ln`** = natural log of mean rainfall CV  
suffix **`vop`** = commodity value of production (international USD)  
suffix **`area`** = commodity area of production (km2)  
suffix **`yield`** = commodity yield (ton/ha)  
suffix **`price`** = 2005 commodity price (international USD/ton)  

```{r Extraction - Spillover countries DT, echo=F}
Stats.Spill.Disp<-reactive({
  FormatExtraction(Data=data.table::copy(Stats.Spillover()),
                 vop_cols=vop_cols(),
                 area_cols=area_cols(),
                 prod_cols=prod_cols(),
                 USD_Units=as.numeric(input$USD_Units),
                 Area_Unit=as.numeric(Area_Unit()),
                 Prod_Unit=as.numeric(input$Prod_Unit),
                 Pop_Unit=as.numeric(input$Pop_Unit),
                 Area_Name=input$Area_Name)
})

  renderDT({
    datatable(dplyr::mutate_if(Stats.Spill.Disp(),is.numeric,~round(.,3)),
                caption="",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  })
```

###### Farming System Areas
This table shows the % area of different farming systems for each country and for the total core or spillover area.
**Note** *the `Total` column values can sum to >100% as the total national areas comes from a shapefile and the farming system areas come from a raster.*

```{r Extraction - Spillover countries FS Area DT, echo=F}

  renderDT({
    datatable(CoreAreasSpill(),
                caption="",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  })
```

#### Productivity increment value{.tabset .tabset-fade .tabset-pills}
The estimated direct benefits of adoption of CSA practices in the selected core countries, expressed as the increase in value (USD) of production per year per the specified percentage productivity increment in crop, meat or milk yields – that is, assuming adoption over all the crop area and all cattle in the target systems of a technology that increased production per ha or per animal by the specified percentages.

```{r Parameter - Annual increment,echo=F}
  numericInput(inputId="AI_PrInc1", 
              label="Productivity increment (%)",
              value = 1,
              min=0,              
              max=100,
              step = 1,
              width="200px")

AI_PrInc<-reactive({input$AI_PrInc1/100})
```

##### Core
This table shows the estimated direct benefits of adoption of CSA practices in the selected core countries, expressed as the increase in value of production per year per `r reactive({input$AI_PrInc1})` % increase in crop and/or livestock yields – that is, assuming adoption over all the crop area and cattle in the target systems of a technology that increased production per ha or per animal per `r reactive({input$AI_PrInc1})` % productivity increment. Units are `r reactive({if(input$USD_Units==1){""}else{input$USD_Units}})` international USD.
```{r Analysis - Annual increment core,echo=F}
AnnInc<-reactive({
  AnnIncFun(Stats.Core=Stats.Core(),
                  vop_cols=vop_cols(),
                  Pr.Inc=AI_PrInc(),
                  AddFS=F)
})
```

```{r Analysis - Annual increment core DT,echo=F}
  renderDT({
    datatable(dplyr::mutate_if(AnnInc(),is.numeric,~round(./as.numeric(input$USD_Units),1)),
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  })
```

##### Spillover
This table shows the estimated direct benefits of adoption of CSA practices in the selected core countries, expressed as the increase in value of production per year per `r reactive({input$AI_PrInc1})` % increase in crop and/or livestock yields – that is, assuming adoption over all the crop area and cattle in the target systems of a technology that increased production per ha or per animal per `r reactive({input$AI_PrInc1})` % productivity increment. Units are `r reactive({if(input$USD_Units==1){""}else{input$USD_Units}})` international USD. These spillover marginal benefits should be estimated using a much lower adoption rate than the core countries (`r reactive({input$SpillFactor})` % of core adoption rates).

```{r Analysis - Annual increment spillover,echo=F}
AnnIncSpill<-reactive({
  AnnIncFun(Stats.Core=Stats.Spillover(),
                  vop_cols=vop_cols(),
                  Pr.Inc=AI_PrInc()*input$SpillFactor/100,
                  AddFS=F)
})
```

```{r Analysis - Annual increment spillover DT,echo=F}
  renderDT({
    datatable(dplyr::mutate_if(AnnIncSpill(),is.numeric,~round(./as.numeric(input$USD_Units),1)),
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  })
```

#### Marginal increase in value{.tabset .tabset-fade .tabset-pills}
Here we modify the benefits from the previous tab for a range of adoption rates `r reactive({paste0("(",paste(100*Ad.Rates.Core(),collapse=", "),"%)")})` and productivity increments `r reactive({paste0("(",paste(100*Pr.Inc(),collapse=", "),"%)")})` at scale. The productivity increments used here should be within what has been observed in many situations for the technology being assessed. Regarding adoption rates, there are not many examples of agricultural technology adoption rates at scale in excess of 2% per year (see Thornton and Herrero, 2010, for example). The annual adoption rates used here refer to the total area of crop and/or number of cattle that have not yet adopted over a `r reactive({input$Years})` year period. So, for example, 2% adoption in year 8 is not the same number as 2% adoption in year 2. For this reason, the estimates of VOP addition are not simple linear multiples of the adoption rate per year shown. For more information on how `Total_adoption` is calculated see the `MarginalInc` function found in the `ERA functions.R` script.

Each row in the table represents a commodity x farming system x country combination for different values of annual adoption rate and productivity increment.   
Explanation of table headings:  

**`Area.ha`** = area of commodity (ha)  
**`Ad.Rate`** = annual adoption rate (proportion)   
**`Pr.Inc`** = productivity increment (proportion)   
**`Y_non_adopt`** = mean yield of non-adopters (t/ha)  
**`Y_adopt`** = mean yield of adopters (t/ha) as `Y_non_adopt*(1+Pr.Inc)`  
**`Year`** = project year  
**`Price`** = 2005 commodity price (international USD/ton)  
**`Cost_adopt`** = estimate of production cost per ha as `Price*Y_adopt/BCR of non-adopters`  
**`Cost_non_adopt`** = estimate of production cost per ha as `Price*Y_non_adopt/BCR of non-adopters`  
**`Total_adoption`** = total adoption of technology (proportion)  
**`A_non_adopt`** = area of non-adopters as `Area*(1-Total_adoption)` (km2)  
**`A_adopt`** = area of adopters (km2) as `Area*Total_adoption`  
**`VOP_non_adopt`** = total value of production for non-adopters (international USD) as `A_non_adopt*Y_non_adopt*Price`    
**`VOP_adopt`** = total value of production for adopters (international USD) as `A_adopt*Y_adopt*Price`  
**`NR_non_adopt`** = net return for non-adopters as `A_adopt*(Y_adopt*Price-Cost_adopt)`  
**`NR_adopt`** = net return for adopters as `A_non_adopt*(Y_non_adopt*Price-Cost_non_adopt)`  
**`Project_benefits`** = marginal value of adoption (international USD) as `NR_non_adopt+NR_adopt-NR_non_adopt_t0` where `NR_non_adopt_t0` is the net return of the system before any technology adoption has occurred.  

##### Core countries{.tabset .tabset-fade .tabset-pills}
These tables show the marginal benefits for value of production in the "core" countries.

###### All Data
```{r Analysis - MI Core, echo=F}
MI.Core<-reactive({
  MIwrapper(Data=Stats.Core(),
          Ad.Rates=Ad.Rates.Core(),
          Pr.Inc=Pr.Inc(),
          Years=input$Years,
          Commodity=c(input$CropChoice,input$LSChoice),
          Non_BCR=input$Non_BCR,
          CostAdopt=input$CostAdopt,
          CostNonAdopt=input$CostNonAdopt)
})
```

```{r Analysis - MI Core DT, echo=F}
  renderDT({
    datatable(dplyr::mutate_if(data.table::copy(MI.Core())[,Ad.Rate:=as.character(Ad.Rate)],is.numeric,~round(.,4)),
                caption="",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  })
```

###### Summary
```{r Analysis - MI Core DT No Countries, echo=F}

MI.Core.Total<-reactive({
  MI.Core()[Year==max(Year),list(Area.ha=sum(Area.ha,na.rm=T),
                  A_non_adopt=sum(A_non_adopt,na.rm=T),
                  A_adopt=sum(A_adopt,na.rm=T),
                  VOP_non_adopt=sum(VOP_non_adopt,na.rm=T)/as.numeric(input$USD_Units),
                  VOP_adopt=sum(VOP_adopt,na.rm=T)/as.numeric(input$USD_Units),
                  NR_non_adopt=sum(NR_non_adopt,na.rm=T)/as.numeric(input$USD_Units),
                  NR_adopt=sum(NR_adopt,na.rm=T)/as.numeric(input$USD_Units),
                  Project_benefits=sum(Project_benefits,na.rm=T)/as.numeric(input$USD_Units)),by=list(Crop,Ad.Rate,Pr.Inc)
            ][,VOP_Total:=VOP_non_adopt+VOP_adopt]
            
})


  renderDT({
    datatable(dplyr::mutate_if(data.table::copy(MI.Core.Total())[,Ad.Rate:=as.character(Ad.Rate)],is.numeric,~round(.,4)),
                caption="",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  })
```

##### Spillover countries{.tabset .tabset-fade .tabset-pills}
These tables show the marginal benefits for value of production in the "extrapolation domain" countries. These spillover marginal benefits should be estimated using a much lower adoption rate than the core countries (`r reactive({input$SpillFactor})` % of core adoption rates) whilst using the same productivity increments.

###### All Data
```{r Analysis - MI Spillover, echo = F}
MI.Spillover<-reactive({
  MIwrapper(Data=Stats.Spillover(),
            Ad.Rates=Ad.Rates.Spillover(),
            Pr.Inc=Pr.Inc(),
            Years=input$Years,
            Commodity=c(input$CropChoice,input$LSChoice),
            Non_BCR=input$Non_BCR,
            CostAdopt=input$CostAdopt,
            CostNonAdopt=input$CostNonAdopt)
  })
```

```{r Analysis - MI Spillover DT, echo=F}
  renderDT({
    datatable(dplyr::mutate_if(data.table::copy(MI.Spillover())[,Ad.Rate:=as.character(Ad.Rate)],is.numeric,~round(.,4)),
                caption="",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  })
```

###### Summary
```{r Analysis - MI Spillover DT No Countries, echo=F}

MI.Spill.Total<-reactive({
  MI.Spillover()[Year==max(Year),list(Area.ha=sum(Area.ha,na.rm=T),
                  A_non_adopt=sum(A_non_adopt,na.rm=T),
                  A_adopt=sum(A_adopt,na.rm=T),
                  VOP_non_adopt=sum(VOP_non_adopt,na.rm=T)/as.numeric(input$USD_Units),
                  VOP_adopt=sum(VOP_adopt,na.rm=T)/as.numeric(input$USD_Units),
                  NR_non_adopt=sum(NR_non_adopt,na.rm=T)/as.numeric(input$USD_Units),
                  NR_adopt=sum(NR_adopt,na.rm=T)/as.numeric(input$USD_Units),
                  Project_benefits=sum(Project_benefits,na.rm=T)/as.numeric(input$USD_Units)),by=list(Crop,Ad.Rate,Pr.Inc)
            ][,VOP_Total:=VOP_non_adopt+VOP_adopt]
            
})


  renderDT({
    datatable(dplyr::mutate_if(data.table::copy(MI.Spill.Total())[,Ad.Rate:=as.character(Ad.Rate)],is.numeric,~round(.,4)),
                caption="",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  })
```

#### Avoided losses from reduction in CV{.tabset .tabset-fade .tabset-pills}
** This is only implemented for crops (not livestock**
The benefits for farmers who use climate information services (CIS) arise from their being able to adjust their management practices to likely imminent or future weather patterns. If the growing season is likely to be wetter than average, then it may be appropriate to increase the use of purchased inputs to increase production and net revenues, for example. For drier conditions, CIS can help farmers and herders reduce production losses via a range of management decisions (such as sale of animals or reducing cropping inputs). The long-term implications of a drought on vulnerable households may be profound, because such a “system shock” can push farmers and their families into poverty from which it can be difficult to escape ([Barrett et al., 2016](https://www.jstor.org/stable/26773368)).  

The use of CIS will not only reduce production variability, it should also increase average yields. This latter effect is not included in the CIS analysis done here as it would double-count the benefits already estimated from non-CIS technology adoption. An assumption of this economic and financial analysis is that non-CSI technology adoption leads to production benefits (increases in distribution means) and that CSI leads to reductions in yield losses in poorer seasons (reductions in production standard deviations). Thus the target populations for non-CIS and CIS technologies should essentially be the same if their benefits are to be considered together.

Annual national yield variability was calculated from FAOSTAT for each of the core countries selected for the maximum amount of time series data available. Yield CVs for the target and extrapolation countries are oresented in the `Datasets::FAO` tab.

Because CIS are still relatively new in SSA, information on the potential for the use of CIS to reduce yield variability is still scarce. To the extent that use of CIS prompts changes in technology choice, the impacts can be significant for example [Wossen et al. (2017)](https://www.sciencedirect.com/science/article/pii/S0301479717306497) reported that yield variance in farmers’ fields can be halved via the use of drought-tolerant maize.

One way to translate reduced yield variability into production benefits is to calculate the economic losses avoided (in terms of value of production) for a percentage reduction in yield CV, measured with respect to the left-hand tail of the production distribution function (PDF). A very approximate estimate is to assume that maize yields in farmers’ fields are distributed normally and calculate the difference in the probability densities of two normal yield density curves, one with the observed mean and yield CV and another with the same mean but a reduced yield CV. For example, if the average yield of maize is 1.24 t/ha, and the yield CV is about 35% the yield standard deviation is 0.43 t/ha. If the CV is reduced to 30% with the same mean, the new standard deviation is 0.37 t/ha. The area between the PDFs of these two normal distributions in the left-hand tails (i.e., the total of the yield loss foregone because of the reduction in CV from 35% to 30%), amounts to 3.3% of total production. Values of the loss avoided are shown in the table below for the same adoption rates used in the previous sections. In practice, mean yields will increase through the use of CIS, but as explained above the focus here is on the avoided losses, which may be extremely important for household food security.

```{r Analysis - CV Subset data to crops,echo=F}
CV_Subset_Core<-reactive({
  FAO_CV[area %in% input$CountriesChoice & SpamName %in% input$CropChoice]
})

CV_Subset_Spill<-reactive({
  FAO_CV[area %in% input$SpillCountriesChoice & SpamName %in% input$CropChoice]
})
```

##### Core{.tabset .tabset-fade .tabset-pills}
```{r Analysis - Core avoided losses,echo=F}
CoreCV<-reactive({
      if(!is.null(input$CropChoice)){
        AvLossWrapper(CV_Data=data.table::copy(CV_Subset_Core()),
                Stats=data.table::copy(MI.Core()),
                CV_Change=input$CV_Change)
      }else{
        list(
          CV_Data=NA,
          Stats=data.table::copy(MI.Core())[,c("AvoidedLossPerc","VOP_CIS","VOP_both"):=NA]
          )
      }
})
```

###### CV table
This table is derived from the FAOSTAT data presented in the **Datasets::FAO** tab. Each row in the extracted data tables represents a crop within a country.  

Explanation of table headings:  
**`N.Years`** = number of years of FAO national yield data available  
**`Yield_Mean`** = mean FAO crop yield (t/ha)  
**`Yield_SD`** = standard deviation of crop yield  
**`CV`** = coefficient of variation for crop yield as `100*(Yield_SD/Yield_Mean)`  
**`CVreduced`** = value of CV following reduction in variability due to use of CIS  
**`AvoidedLossPerc`** = reduction in yield losses due to climate variability from use of CIS (%).  For more information on how `AvoidedLossPerc` is calculated see the `AvLoss` function in the `ERA functions.R` script.
```{r Analysis -  Core avoided losses DT CV_Data, echo=F,error=F}
  renderDT({
    if(!is.null(input$CropChoice)){
      datatable(dplyr::mutate_if(CoreCV()$CV_Data,is.numeric,~round(.,3)),
                caption="",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
        }
  })
```

###### Marginal VoP inc. Non-CIS + CIS
Each row in the table represents a commodity x farming system x country x project year combination for different values of annual adoption rate and productivity increment.  

Explanation of table headings:   
**`Area.ha`** = area of commodity (ha)    
**`Ad.Rate`** = annual adoption rate (proportion)    
**`Pr.Inc`** = productivity increment (proportion)    
**`Y_non_adopt`** = mean yield of non-adopters (t/ha)    
**`Y_adopt`** = mean yield of adopters (t/ha) as `Y_non_adopt*(1+Pr.Inc)`    
**`Year`** = project year    
**`Price`** = 2005 commodity price (international USD/ton)   
**`Cost_adopt`** = estimate of production cost per ha as `Price*Y_adopt/BCR of non-adopters`  
**`Cost_non_adopt`** = estimate of production cost per ha as `Price*Y_non_adopt/BCR of non-adopters`   
**`Total_adoption`** = total adoption of technology (proportion)  
**`A_non_adopt`** = area of non-adopters as `Area*(1-Total_adoption)` (km2)   
**`A_adopt`** = area of adopters (km2) as `Area*Total_adoption`   
**`VOP_non_adopt`** = total value of production for non-adopters (international USD) as `A_non_adopt*Y_non_adopt*Price`; **`VOP_adopt`** = total value of production for adopters (international USD) as `A_adopt*Y_adopt*Price`  
**`NR_non_adopt`** = net return for non-adopters as `A_adopt*(Y_adopt*Price-Cost_adopt)`  
**`NR_adopt`** = net return for adopters as `A_non_adopt*(Y_non_adopt*Price-Cost_non_adopt)`  
**`Project_benefits`** = marginal value of adoption (international USD) as `NR_non_adopt+NR_adopt-NR_non_adopt_t0` where `NR_non_adopt_t0` is the net return of the system before any technology adoption has occurred   
**`AvoidedLossPerc`** = reduction in yield losses due to climate variability from use of CIS (%)    
**`VOP_CIS`**  marginal value of adoption of CIS technologies (international USD) as `AvoidedLossPerc*Y_adopt*A_adopt*Price`    
**`VOP_Both`** combined value of non-CIS and CIS technologies adoption as `Project_benefits+VOP_CIS`

```{r Analysis -  Core avoided losses DT Stats, echo=F}
renderDT({
    datatable(dplyr::mutate_if(CoreCV()$Stats[,Ad.Rate:=as.character(Ad.Rate)],is.numeric,~round(.,3)),
                caption="",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  })
```

###### Summary
```{r Analysis - Core avoided losses DT Summary, echo=F}
CoreCVSummary<-reactive({
  CoreCV()$Stats[Year==max(Year),
                 list(Area.ha=sum(Area.ha,na.rm=T),
                    A_non_adopt=sum(A_non_adopt,na.rm=T),
                    A_adopt=sum(A_adopt,na.rm=T),
                    VOP_non_adopt=sum(VOP_non_adopt,na.rm=T)/as.numeric(input$USD_Units),
                    VOP_adopt=sum(VOP_adopt,na.rm=T)/as.numeric(input$USD_Units),
                    VOP_CIS=sum(VOP_CIS,na.rm = T)/as.numeric(input$USD_Units),
                    VOP_both=sum(VOP_both,na.rm = T)/as.numeric(input$USD_Units)),
                 by=list(Crop,Ad.Rate,Pr.Inc)
                 ][,Ad.Rate:=as.character(Ad.Rate)][,VOP_Total:=VOP_non_adopt+VOP_adopt]
            
})

renderDT({
  datatable(dplyr::mutate_if(CoreCVSummary(),is.numeric,~round(.,3)),
              caption="",
              extensions = 'Buttons',
              filter = "top",
              options = list(dom = 'Blfrtip',
                             buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                             lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
})
```

##### Spillover{.tabset .tabset-fade .tabset-pills}
```{r Analysis - Spillover avoided losses,echo=F}
SpilloverCV<-reactive({
   if(!is.null(input$CropChoice)){
     AvLossWrapper(CV_Data=data.table::copy(CV_Subset_Spill()),
                Stats=data.table::copy(MI.Spillover()),
                CV_Change=input$CV_Change)
   }else{
     list(
       CV_Data=NA,
       Stats=data.table::copy(MI.Spillover())[,c("AvoidedLossPerc","VOP_CIS","VOP_both"):=NA]
       )
      }
})

```

###### CV table
This table is derived from the FAOSTAT data presented in the **Datasets::FAO** tab. Each row in the extracted data tables represents a crop within a country.  

Explanation of table headings:  
**`N.Years`** = number of years of FAO national yield data available  
**`Yield_Mean`** = mean FAO crop yield (t/ha)  
**`Yield_SD`** = standard deviation of crop yield  
**`CV`** = coefficient of variation for crop yield as `100*(Yield_SD/Yield_Mean)`  
**`CVreduced`** = value of CV following reduction in variability due to use of CIS  
**`AvoidedLossPerc`** = reduction in yield losses due to climate variability from use of CIS (%).  For more information on how `AvoidedLossPerc` is calculated see the `AvLoss` function in the `ERA functions.R` script.
```{r Analysis -  Spillover avoided losses DT CV_Data, echo=F}
  renderDT({
       if(!is.null(input$CropChoice)){
         datatable(dplyr::mutate_if(SpilloverCV()$CV_Data,is.numeric,~round(.,3)),
                   caption="",
                   extensions = 'Buttons',
                   filter = "top",
                   options = list(dom = 'Blfrtip',
                                  buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                                  lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
         }
  })
```

###### Marginal VoP inc. Non-CIS + CIS
Each row in the table represents a commodity x farming system x country x project year combination for different values of annual adoption rate and productivity increment.  

Explanation of table headings:   
**`Area.ha`** = area of commodity (ha)    
**`Ad.Rate`** = annual adoption rate (proportion)    
**`Pr.Inc`** = productivity increment (proportion)    
**`Y_non_adopt`** = mean yield of non-adopters (t/ha)    
**`Y_adopt`** = mean yield of adopters (t/ha) as `Y_non_adopt*(1+Pr.Inc)`    
**`Year`** = project year    
**`Price`** = 2005 commodity price (international USD/ton)   
**`Cost_adopt`** = estimate of production cost per ha as `Price*Y_adopt/BCR of non-adopters`  
**`Cost_non_adopt`** = estimate of production cost per ha as `Price*Y_non_adopt/BCR of non-adopters`   
**`Total_adoption`** = total adoption of technology (proportion)  
**`A_non_adopt`** = area of non-adopters as `Area*(1-Total_adoption)` (km2)   
**`A_adopt`** = area of adopters (km2) as `Area*Total_adoption`   
**`VOP_non_adopt`** = total value of production for non-adopters (international USD) as `A_non_adopt*Y_non_adopt*Price`; **`VOP_adopt`** = total value of production for adopters (international USD) as `A_adopt*Y_adopt*Price`  
**`NR_non_adopt`** = net return for non-adopters as `A_adopt*(Y_adopt*Price-Cost_adopt)`  
**`NR_adopt`** = net return for adopters as `A_non_adopt*(Y_non_adopt*Price-Cost_non_adopt)`  
**`Project_benefits`** = marginal value of adoption (international USD) as `NR_non_adopt+NR_adopt-NR_non_adopt_t0` where `NR_non_adopt_t0` is the net return of the system before any technology adoption has occurred   
**`AvoidedLossPerc`** = reduction in yield losses due to climate variability from use of CIS (%)    
**`VOP_CIS`**  marginal value of adoption of CIS technologies (international USD) as `AvoidedLossPerc*Y_adopt*A_adopt*Price`    
**`VOP_Both`** combined value of non-CIS and CIS technologies adoption as `Project_benefits+VOP_CIS`
```{r Analysis -  Spillover avoided losses DT Stats, echo=F}
renderDT({
  datatable(dplyr::mutate_if(SpilloverCV()$Stats[,Ad.Rate:=as.character(Ad.Rate)],is.numeric,~round(.,3)),
              caption="Select crops",
              extensions = 'Buttons',
              filter = "top",
              options = list(dom = 'Blfrtip',
                             buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                             lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
})
```

###### Summary
```{r Analysis - Spillover avoided losses DT Summary, echo=F}
SpillCVSummary<-reactive({
  SpilloverCV()$Stats[Year==max(Year),
                      list(Area.ha=sum(Area.ha,na.rm=T),
                        A_non_adopt=sum(A_non_adopt,na.rm=T),
                        A_adopt=sum(A_adopt,na.rm=T),
                        VOP_non_adopt=sum(VOP_non_adopt,na.rm=T)/as.numeric(input$USD_Units),
                        VOP_adopt=sum(VOP_adopt,na.rm=T)/as.numeric(input$USD_Units),
                        VOP_CIS=sum(VOP_CIS,na.rm = T)/as.numeric(input$USD_Units),
                        VOP_both=sum(VOP_both,na.rm = T)/as.numeric(input$USD_Units)), 
                      by=list(Crop,Ad.Rate,Pr.Inc)
                  ][,Ad.Rate:=as.character(Ad.Rate)][,VOP_Total:=VOP_non_adopt+VOP_adopt]
            
})

renderDT({
  datatable(dplyr::mutate_if(SpillCVSummary(),is.numeric,~round(.,3)),
              caption="",
              extensions = 'Buttons',
              filter = "top",
              options = list(dom = 'Blfrtip',
                             buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                             lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
})
```

#### Investment indicators  {.tabset .tabset-fade .tabset-pills}
The information presented in the previous tabs illustrates estimated changes in the value of production of different commodities for different production increments and adoption rates. To estimate returns on investment, some estimate is needed of the direct costs of implementing non-CIS and CIS technologies at the farm level, so that cash flows can be calculated on changes in net profits or grow margins per ha or per animal.

Each row in the Indicator tab shows the [Net Present Value (NPV)](https://www.investopedia.com/terms/n/npv.asp), [Internal Rate of Return (IRR)](https://www.investopedia.com/terms/i/irr.asp) and [Benefit-Cost Ratio (BCR)](https://www.investopedia.com/terms/b/bcr.asp) for the selected ranges of adoption rates and yield increments, with the assumptions that the investment is allocated to the indicator commodities, and that the marginal VOP additions each year from non-CIS and CIS adoption minus costs.

**Choose Crops/Livestock**
```{r Analysis - Choose crops}
renderUI({
checkboxGroupInput(inputId="InvestStatCrops", 
         label= NULL, 
         choices = c(input$CropChoice,input$LSChoice), 
         selected = c(input$CropChoice,input$LSChoice)[1],
         inline = T)
})
```
Explanation of table headings:   
**`Ad.Rate`** = annual adoption rate (proportion)   
**`Pr.Inc`** = productivity increment (proportion)    
**`CISinc`**  indicates if estimates of CIS benefits are included in calculations or not    
**`Periods`** = project duration (years)    
**`StartPeriod`** = the period (year) in which returns start    
**`Avoided_loss_mean`** = the mean reduction in yield losses due to climate variability from use of CIS (percentage), the mean is calculated across all farming system x crop x country combinations   
**`Implied Adoption`** = total assumed adoption of technologies in core countries    
[**`NPV`**](https://www.investopedia.com/terms/n/npv.asp) = net-present value (international USD)    
[**`BCR`**](https://www.investopedia.com/terms/b/bcr.asp) = benefit-cost ratio as `NPV/ProjectCost`    
[**`IRR`**](https://www.investopedia.com/terms/i/irr.asp) = internal rate of return (see the `irr` function in in the `ERA functions.R` script for methodological details).

```{r Analysis - NPV Calc 1 Core,echo=F}
InvestDataCore<-reactive({
  InvestDataWrapper(Data=CoreCV()$Stats,
                    InvestStatCrops=input$InvestStatCrops,
                    ProjectCost=ProjectCost(),
                    DiscountRate=DiscountRate(),
                    StartPeriod=StartYear())
})
```

```{r Analysis - NPV Calc 1,echo=F}
InvestDataCS<-reactive({
  InvestDataWrapper(Data= rbind(CoreCV()$Stats,data.table::copy(SpilloverCV()$Stats)[,Ad.Rate:=Ad.Rate*(100/input$SpillFactor)]),
                    InvestStatCrops=input$InvestStatCrops,
                    ProjectCost=ProjectCost(),
                    DiscountRate=DiscountRate(),
                    StartPeriod=StartYear())
})
```

##### Indicators
The discount rate used in NPV calculations is `r reactive({100*DiscountRate()})`% and the project cost is `r reactive({ProjectCost()/10^6})` million USD.

**Calculated only considering core countries**
```{r Analysis - Indicators Core DT, echo=F}
  renderDT({
    datatable(InvestDataCore()$Indicators[,NPV:=round(NPV/as.numeric(input$USD_Units),3)
                                                  ][,BCR:=round(BCR,3)
                                                  ][,IRR:=round(IRR,3)
                                                    ][,Implied_Adoption:=round(Implied_Adoption,3)
                                                      ][,Avoided_loss_mean:=abs(round(Avoided_loss_mean,3))],
                caption="",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  })
```

**Calculated considering both core and spillover countries.** *Note that implied adoption only consider adoption in core countries, in spillover countries adoption is assumed to be `r reactive({input$SpillFactor})` `%` of that in core countries.*

```{r Analysis - Indicators Core + Spillover DT, echo=F}
  renderDT({
    datatable(InvestDataCS()$Indicators[,NPV:=round(NPV/as.numeric(input$USD_Units),3)
                                                  ][,BCR:=round(BCR,3)
                                                  ][,IRR:=round(IRR,3)
                                                    ][,Implied_Adoption:=round(Implied_Adoption,3)
                                                      ][,Avoided_loss_mean:=abs(round(Avoided_loss_mean,3))],
                caption="",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  })
```

##### Cashflow {.tabset .tabset-fade .tabset-pills}
Each row in the table represents a commodity x farming system x country x project year combination for different values of annual adoption rate and productivity increment.  

Explanation of table headings: 
**`Ad.Rate`** = annual adoption rate (proportion)   
**`Pr.Inc`** = productivity increment (proportion)  
**`Year`** = project year  
**`Total_adoption`** = total adoption of technology (proportion)   
**`AvoidedLossPerc`** = reduction in yield losses due to climate variability from use of CIS (%)  
**`CISinc`**  indicates if estimates of CIS benefits are included in calculations or not   
**`Cashflow`** = marginal value of adoption (international USD) as calculated in previous tabs  (see `Project_benefits` columns).  

The discount rate used in calculations is `r reactive({100*DiscountRate()})`%.

###### Core only
```{r Analysis - NPV Calc 1 DT Core, echo=F}

  renderDT({
    datatable(dplyr::mutate_if(InvestDataCore()$InvestData,is.numeric,~round(.,3)),
                caption="",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  })
```

###### Core + Spillover
*Note that the display of the annual adoption rate `Ad.Rate` for spillover countries is not adjusted by the spillover factor, but the analysis does take this into account.*
```{r Analysis - NPV Calc 1 DT, echo=F}

  renderDT({
    datatable(dplyr::mutate_if(InvestDataCS()$InvestData,is.numeric,~round(.,3)),
                caption="",
                extensions = 'Buttons',
                filter = "top",
                options = list(dom = 'Blfrtip',
                               buttons = c('copy', 'csv', 'excel', 'pdf', 'print'),
                               lengthMenu = list(c(10,25,50,-1),c(10,25,50,"All"))))
  })
```

### Annex
**Calculations**

From the gridded data, we have:  

* VOP, value of production ($ per year)    
*	A, area planted, or numbers of cattle (ha or head)   
*	P, production (t)  
*	R, price ($/t), given by VOP / P  
  
Assume adoption rate a (% per year)  
Assume a productivity increment y (%, flat rate one-off)  
  
Y = P/A in t/ha or kg/head  
NB we used derived yields rather than spatial values because of spatial data alignment issues.  
  
For adopters over 10 years,   
Y’ = Y * (1+y/100)		increased yield  
A’ = A * (1 + a/100)^10 – A	increasing area under adoption, a% per year  
VOP’ = Y’ * A’ * R		VOP from adopters  
   
For non-adopters,  
Y’’ = Y				same yield  
A’’ = A – A’ 			decreasing share of the area as adoption increases through time  
VOP’’ = Y * A’’ * R		VOP from non-adopters  
  
VOP tot = VOP’ + VOP’’		At year 10, total VOP from adopters and non-adopters  
  
Thus the marginal benefits of adoption per year at year 10 is:  
VOP delta = VOP tot – VOP  
  
After some algebra,  
VOP delta = VOP * (1 - (((1+a/100)^10 ) - 1)) + VOP * (1+y/100) * (((1+a0/100)^10) - 1) – VOP  


### Session Info
```{r Session Info, echo=F}
sessionInfo()
```
